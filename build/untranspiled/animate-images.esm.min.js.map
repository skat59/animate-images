{"version":3,"file":"animate-images.esm.min.js","sources":["../../src/utils.js","../../src/settings.js","../../src/ImagePreloader.js","../../src/Render.js","../../src/Animation.js","../../src/Poster.js","../../src/DragInput.js","../../src/AnimateImages.js"],"sourcesContent":["export function normalizeFrameNumber(frameNumber, totalImages){\r\n    frameNumber = Math.floor(frameNumber);\r\n    if (frameNumber <= 0) {\r\n        return 1;\r\n    } else if (frameNumber > totalImages) {\r\n        return totalImages;\r\n    }\r\n    return frameNumber;\r\n}\r\n\r\nexport function calculateFullAnimationDuration(imagesNumber, fps){\r\n    return imagesNumber / fps  * 1000;\r\n}\r\n\r\nexport function uppercaseFirstChar(word){\r\n    return word.charAt(0).toUpperCase() + word.slice(1);\r\n}","export function validateInitParameters(node, options){\r\n    if ( !(node instanceof HTMLCanvasElement) ) { // Check dom node\r\n        throw new TypeError('node is required and should be canvas element');\r\n    }\r\n    if (!options.images || !Array.isArray(options.images) || options.images.length <= 1 ) { // Check images list\r\n        throw new TypeError('options.images is required and must be an array with more than 1 element');\r\n    }\r\n    // if ( (\"preload\" in options) && // Check preload type\r\n    //     (\r\n    //         !(typeof options.preload  === \"string\")\r\n    //         || !(options.preload === \"all\" || options.preload === \"none\" || options.preload === \"partial\")\r\n    //     )\r\n    // ) {\r\n    //     throw new TypeError('options.preload must be one of these: all, none, partial');\r\n    // }\r\n    // if ( (\"preloadNumber\" in options)\r\n    //     && !( Number.isInteger(Number.parseInt(options.preloadNumber)) && Number.parseInt(options.preloadNumber) >= 0 )\r\n    // ) {\r\n    //     throw new TypeError('options.preloadNumber must be number >= 0');\r\n    // }\r\n    if ('preloadNumber' in options) options.preloadNumber = Number.parseInt(options.preloadNumber); // Allow number as a string\r\n    if (\"fillMode\" in options && !['cover', 'contain'].includes(options.fillMode))  delete options['fillMode'];\r\n    if ('dragModifier' in options) options.dragModifier = Math.abs(+options.dragModifier);\r\n}\r\n\r\nexport const defaultSettings = {\r\n    preload: \"all\",\r\n    preloadNumber: 0,\r\n    poster: false,\r\n    fps: 30,\r\n    loop: false,\r\n    autoplay: false,\r\n    reverse: false,\r\n    ratio: undefined,\r\n    fillMode: \"cover\",\r\n\r\n    draggable: false,\r\n    inversion: false,\r\n    dragModifier: 1,\r\n    touchScrollMode: \"pageScrollTimer\",\r\n    pageScrollTimerDelay: 1500,\r\n    responsiveAspect: \"width\",\r\n\r\n    fastPreview: false,\r\n\r\n    onFastPreloadFinished: noOp,\r\n    onPreloadFinished: noOp,\r\n    onPosterLoaded: noOp,\r\n    onAnimationEnd: noOp,\r\n    onBeforeFrame: noOp,\r\n    onAfterFrame: noOp,\r\n}\r\n\r\nexport const eventPrefix = \"animate-images:\";\r\n\r\nfunction noOp(){}\r\n","import { eventPrefix } from \"./settings\";\r\n\r\nexport default class ImagePreloader{\r\n\r\n    constructor( {settings, data, updateImagesCount, getFramesLeft} ) {\r\n        this._settings = settings;\r\n        this._data = data;\r\n        this._updateImagesCount = updateImagesCount;\r\n        this._getFramesLeft = getFramesLeft;\r\n\r\n        // Public\r\n        this._isPreloadFinished = false;// onload on all the images\r\n        this._isFastPreloadFinished = false;// images from fastPreload mode\r\n        this._isAnyPreloadFinished = false;\r\n        this._isLoadedWithErrors = false;\r\n\r\n        // Internal\r\n        this._preloadOffset = 0;// images already in queue\r\n        this._preloadedCount = 0;// count of loaded images\r\n        this._tempImagesArray = []; // store images before they are fully loaded\r\n        this._failedImages = [];\r\n        this._currentMode = \"default\";// \"default\" or \"fast\"\r\n        this._modes = {\r\n            default: {\r\n                images: this._settings.images,\r\n                event: eventPrefix + \"preload-finished\",\r\n                callback: this._settings.onPreloadFinished,\r\n            },\r\n            fast: {\r\n                images: this._settings?.fastPreview.images,\r\n                event: eventPrefix + \"fast-preload-finished\",\r\n                callback: this._settings.onFastPreloadFinished,\r\n            }\r\n        }\r\n\r\n        // set mode if fast preview\r\n        if (this._settings.fastPreview) {\r\n            if ( !this._settings.fastPreview.images ) {\r\n                throw new TypeError('fastPreview.images is required when fastPreview is enabled');\r\n            }\r\n            this._currentMode = \"fast\";\r\n            this._data.totalImages = this._settings.fastPreview.images.length;\r\n        }\r\n        this._totalImages = this._data.totalImages; // get initial value for the first time, update when fast => default mode\r\n    }\r\n\r\n    /**\r\n     * Add number of images to loading queue\r\n     * @param {number} [preloadNumber] - number of images to load\r\n     */\r\n    _startLoading(preloadNumber){\r\n        if (this._isPreloadFinished) return;\r\n        if ( !preloadNumber ) preloadNumber = this._totalImages;\r\n        preloadNumber = Math.round(preloadNumber);\r\n\r\n        // if too many, load just the rest\r\n        const unloadedCount = this._totalImages - this._preloadOffset;\r\n        if (preloadNumber > unloadedCount){\r\n            preloadNumber = unloadedCount;\r\n        }\r\n\r\n        // true when all the images are in queue but not loaded yet, (unloadedCount = preloadNumber = 0)\r\n        if (preloadNumber <= 0) return;\r\n\r\n        //console.log(`start loop, preloadNumber=${preloadNumber}, offset=${this._preloadOffset}`);\r\n        for (let i = this._preloadOffset; i < (preloadNumber + this._preloadOffset); i++){\r\n            let img = new Image();\r\n            img.onload = img.onerror = this.#onImageLoad.bind(this);\r\n            img.src = this._modes[this._currentMode].images[i]\r\n            this._tempImagesArray[i] = img;\r\n        }\r\n        this._preloadOffset = this._preloadOffset + preloadNumber;\r\n    }\r\n\r\n    #onImageLoad(e){\r\n        this._preloadedCount++;\r\n        const progress = Math.floor((this._preloadedCount/this._totalImages) * 1000) / 1000 ;\r\n        this._data.canvas.element.dispatchEvent( new CustomEvent(eventPrefix + 'loading-progress', {detail: {progress}}) );\r\n        if (e.type === \"error\") {\r\n            this._isLoadedWithErrors = true;\r\n            const path = e.path || (e.composedPath && e.composedPath());\r\n            this._failedImages.push(path[0]);\r\n            this._data.canvas.element.dispatchEvent( new Event(eventPrefix + 'loading-error') );\r\n        }\r\n        if (this._preloadedCount >= this._totalImages) {\r\n            if ( this._isLoadedWithErrors ) this.#clearImagesArray();\r\n            this.#afterPreloadFinishes();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove failed images from array\r\n     */\r\n    #clearImagesArray(){\r\n        if ( this._failedImages.length < 1) return;\r\n        this._tempImagesArray = this._tempImagesArray.filter((el) => {\r\n            return !this._failedImages.includes(el);\r\n        });\r\n    }\r\n\r\n    #afterPreloadFinishes(){ // check what to do next\r\n        if (this._currentMode === \"default\"){\r\n            this._isPreloadFinished = true;\r\n        } else {\r\n            this._isFastPreloadFinished = true;\r\n        }\r\n        this._isAnyPreloadFinished = true; // variable for checks from main plugin\r\n        this._data.loadedImagesArray = [...this._tempImagesArray];\r\n        this._data.totalImages = this._tempImagesArray.length;\r\n        this._updateImagesCount();\r\n\r\n        // we should call deferredAction and callback after \"setFrame\" inside next \"if\", because setFrame will replace\r\n        // these actions, so save current mode before it will be changed inside \"if\", and use for  deferredAction and callback\r\n        const savedMode = this._currentMode;\r\n        const plugin = this._data.pluginApi;\r\n        // code below executes only if fastPreview is set\r\n        if ( this._currentMode === \"fast\" ) { // fast preload has ended\r\n            this._currentMode = \"default\";\r\n            this._tempImagesArray = [];\r\n            this._preloadOffset = this._preloadedCount = 0;\r\n            this._totalImages = this._settings.images.length; // update for default preload mode\r\n            // start preload full list if we have action, that started after fast preload end\r\n            if ( this._data.deferredAction ) this._startLoading();\r\n        } else if ( this._currentMode === \"default\" && this._settings.fastPreview ) { // default preload has ended (only after fast),\r\n            // replace small sequence with full and change frame\r\n            if (this._settings?.fastPreview.fpsAfter) plugin.setOption(\"fps\", this._settings?.fastPreview.fpsAfter)\r\n            const wasAnimating = plugin.isAnimating();\r\n            const framesAreInQueue = typeof this._getFramesLeft() !== 'undefined'; // true if playTo or playFrames is active\r\n            const matchFrame = this._settings?.fastPreview.matchFrame;\r\n            plugin.setFrame( matchFrame ? matchFrame(this._data.currentFrame) : 1 );\r\n            // play() => continue, playTo() or playFrames() => stop, because it is impossible\r\n            // to calculate new target frame from _framesLeftToPlay\r\n            //https://github.com/its2easy/animate-images/issues/7#issuecomment-1210624687\r\n            if ( wasAnimating && !framesAreInQueue ) plugin.play();\r\n        }\r\n\r\n        // actions and callbacks\r\n        if (this._data.deferredAction) {\r\n            this._data.deferredAction();\r\n            // clear to prevent from being called twice when action was queued before the end of fastPreview preload\r\n            this._data.deferredAction = null;\r\n        }\r\n        this._data.canvas.element.dispatchEvent( new Event(this._modes[savedMode].event) );\r\n        this._modes[savedMode].callback(plugin);\r\n\r\n    }\r\n\r\n    // Case when fast preload had ended, but we don't have deferred action, because action started with preview frames,\r\n    // this is possible only with preload=\"all\"; or with any preload after plugin.preloadImages() before any action,\r\n    // and we have to start full preload here.\r\n    // This function is called only after frame change was requested.\r\n    _maybePreloadAll(){\r\n        if (this._settings.fastPreview && !this._isPreloadFinished) this._startLoading();\r\n    }\r\n\r\n}\r\n","export default class Render{\r\n\r\n    constructor( {settings, data} ) {\r\n        this._settings = settings;\r\n        this._data = data;\r\n        /** @type CanvasRenderingContext2D */\r\n        this._context = this._data.canvas.element.getContext(\"2d\");\r\n    }\r\n\r\n    /**\r\n     * @param {HTMLImageElement} imageObject - image object\r\n     */\r\n    _drawFrame(imageObject){\r\n        //this._context.imageSmoothingEnabled = false; // may reduce blurriness, but could make the image worse (resets to true  after resize)\r\n\r\n        let sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight;\r\n        if (this._settings.fillMode === \"cover\") {\r\n            ( {sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight} = this.#getDrawImageCoverProps(imageObject) )\r\n        } else if ( this._settings.fillMode === \"contain\" ) {\r\n            ( {sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight} = this.#getDrawImageContainProps(imageObject) )\r\n        }\r\n\r\n        //console.log(`sx= ${sx}, sy=${sy}, sWidth=${sWidth}, sHeight=${sHeight}, dx=${dx}, dy=${dy}, dWidth=${dWidth}, dHeight=${dHeight}`);\r\n        const canvasEl = this._data.canvas.element;\r\n        this._settings.onBeforeFrame(this._data.pluginApi,\r\n            {context: this._context, width: canvasEl.width, height: canvasEl.height});\r\n\r\n        this._context.drawImage(imageObject, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\r\n\r\n        this._settings.onAfterFrame(this._data.pluginApi,\r\n            {context: this._context, width: canvasEl.width, height: canvasEl.height});\r\n    }\r\n\r\n    _clearCanvas(){\r\n        const canvasEl = this._data.canvas.element;\r\n        this._context.clearRect(0, 0, canvasEl.width, canvasEl.height);\r\n    }\r\n\r\n    #getDrawImageCoverProps(image){\r\n        //https://stackoverflow.com/questions/21961839/simulation-background-size-cover-in-canvas\r\n        let dx = 0,\r\n            dy = 0,\r\n            canvasWidth = this._data.canvas.element.width,\r\n            canvasHeight = this._data.canvas.element.height,\r\n            imageWidth = image.naturalWidth,\r\n            imageHeight = image.naturalHeight,\r\n            offsetX = 0.5,\r\n            offsetY = 0.5,\r\n            minRatio = Math.min(canvasWidth / imageWidth, canvasHeight / imageHeight),\r\n            newWidth = imageWidth * minRatio,   // new prop. width\r\n            newHeight = imageHeight * minRatio,   // new prop. height\r\n            sx, sy, sWidth, sHeight, ar = 1;\r\n\r\n        // decide which gap to fill\r\n        if (newWidth < canvasWidth) ar = canvasWidth / newWidth;\r\n        if (Math.abs(ar - 1) < 1e-14 && newHeight < canvasHeight) ar = canvasHeight / newHeight;  // updated\r\n        newWidth *= ar;\r\n        newHeight *= ar;\r\n\r\n        // calc source rectangle\r\n        sWidth = imageWidth / (newWidth / canvasWidth);\r\n        sHeight = imageHeight / (newHeight / canvasHeight);\r\n\r\n        sx = (imageWidth - sWidth) * offsetX;\r\n        sy = (imageHeight - sHeight) * offsetY;\r\n\r\n        // make sure source rectangle is valid\r\n        if (sx < 0) sx = 0;\r\n        if (sy < 0) sy = 0;\r\n        if (sWidth > imageWidth) sWidth = imageWidth;\r\n        if (sHeight > imageHeight) sHeight = imageHeight;\r\n\r\n        return { sx, sy, sWidth, sHeight, dx, dy, dWidth: canvasWidth, dHeight: canvasHeight };\r\n    }\r\n    #getDrawImageContainProps(image){\r\n        let canvasWidth = this._data.canvas.element.width,\r\n            canvasHeight = this._data.canvas.element.height,\r\n            imageWidth = image.naturalWidth,\r\n            imageHeight = image.naturalHeight,\r\n            sx = 0,\r\n            sy = 0,\r\n            sWidth = imageWidth,\r\n            sHeight = imageHeight,\r\n            dx,\r\n            dy,\r\n            offsetX = 0.5,\r\n            offsetY = 0.5,\r\n            ratioX = canvasWidth / imageWidth,\r\n            ratioY = canvasHeight / imageHeight,\r\n            minRation = Math.min(ratioX, ratioY),\r\n            newWidth = imageWidth * minRation,\r\n            newHeight = imageHeight * minRation;\r\n\r\n        dx = (canvasWidth - newWidth) * offsetX;\r\n        dy = (canvasHeight - newHeight) * offsetY;\r\n\r\n        return { sx, sy, sWidth, sHeight, dx, dy, dWidth: newWidth, dHeight: newHeight};\r\n    }\r\n}\r\n","import { eventPrefix } from \"./settings\";\r\n\r\nexport default class Animation{\r\n    // Public\r\n    _isAnimating;\r\n    _framesLeftToPlay; // frames from playTo() and playFrames()\r\n\r\n    // Internal\r\n    _lastUpdate; // time from RAF\r\n    _duration; // time of the full animation sequence\r\n    _stopRequested;\r\n    _framesQueue; // save decimal part if deltaFrames is not round, to prevent rounding errors\r\n    _progressThreshold; // >35% mea`ns that there was a long task in callstack\r\n\r\n    constructor( {settings, data, changeFrame} ) {\r\n        this._settings = settings;\r\n        this._data = data;\r\n        this._changeFrame = changeFrame;\r\n\r\n        this._stopRequested = false;\r\n        this._isAnimating = false;\r\n        this._framesQueue = 0;\r\n        this._progressThreshold = 0.35;\r\n\r\n        this._updateDuration();\r\n    }\r\n\r\n    _play(){\r\n        this._isAnimating = true;\r\n         this._stopRequested = false; // fix for the case when stopRequested was set inside getNextFrame that was called outside #animate\r\n        if ( !this._data.isAnyFrameChanged ) { // 1st paint, direct call because 1st frame wasn't drawn\r\n            this._changeFrame(1);\r\n            // subtract 1 manually, because changeFrame is calling not from animate(), but directly\r\n            if ( Number.isFinite(this._framesLeftToPlay) ) this._framesLeftToPlay--; // undefined-- = NaN\r\n        }\r\n\r\n         this._lastUpdate = null;// first 'lastUpdate' should be always set in the first raf of the current animation\r\n        requestAnimationFrame(this.#animate.bind(this));\r\n    }\r\n    _stop(){\r\n        const wasAnimating = this._isAnimating;\r\n        this._isAnimating = false;\r\n        this._framesLeftToPlay = undefined;\r\n        if ( wasAnimating ){ // !!! callbacks and events should be called after all the values are reset\r\n            this._data.canvas.element.dispatchEvent( new Event(eventPrefix + 'animation-end') );\r\n            this._settings.onAnimationEnd(this._data.pluginApi);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get next frame number, based on current state and settings\r\n     * @param {Number} deltaFrames -\r\n     * @param {Boolean} reverse\r\n     * @returns {number|*}\r\n     */\r\n    _getNextFrame(deltaFrames, reverse = undefined){\r\n        deltaFrames = Math.floor(deltaFrames); //just to be safe\r\n        // Handle reverse\r\n        if ( reverse === undefined ) reverse = this._settings.reverse;\r\n        let newFrameNumber = reverse ? this._data.currentFrame - deltaFrames : this._data.currentFrame + deltaFrames\r\n\r\n        // Handle loop\r\n        if (this._settings.loop) { // loop and outside of the frames\r\n            if (newFrameNumber <= 0) {\r\n                // for example newFrame = -2, total = 50, newFrame = 50 - abs(-2) = 48\r\n                newFrameNumber = this._data.totalImages - Math.abs(newFrameNumber);\r\n            }\r\n            else if (newFrameNumber > this._data.totalImages) {\r\n                // for example newFrame = 53, total 50, newFrame = newFrame - totalFrames = 53 - 50 = 3\r\n                newFrameNumber = newFrameNumber - this._data.totalImages;\r\n            }\r\n        } else { // no loop and outside of the frames\r\n            if (newFrameNumber <= 0) {\r\n                newFrameNumber = 1;\r\n                this._stopRequested = true;\r\n            }\r\n            else if (newFrameNumber > this._data.totalImages) {\r\n                newFrameNumber = this._data.totalImages;\r\n                 this._stopRequested = true;\r\n            }\r\n        }\r\n        return  newFrameNumber;\r\n    }\r\n\r\n    // RAF callback\r\n    // (chrome) 'timestamp' is timestamp from the moment the RAF callback was queued\r\n    // (firefox) 'timestamp' is timestamp from the moment the RAF callback was called\r\n    // the difference is equal to the time that the main thread was executing after raf callback was queued\r\n    #animate(timestamp){\r\n        if ( !this._isAnimating ) return;\r\n\r\n        // lastUpdate is setting here because the time between play() and #animate() is unpredictable, and\r\n        // lastUpdate = performance.now instead of timestamp because timestamp is unpredictable and depends on the browser.\r\n        // Possible frame change in the first raf will always be skipped, because time <= performance.now\r\n        if ( ! this._lastUpdate)  this._lastUpdate = performance.now();\r\n\r\n        let deltaFrames;\r\n        // Check if there was a long task between this and the last frame, if so move 1 fixed frame and change lastUpdate to now\r\n        // to prevent animation jump. (1,2,3,long task,75,76,77, ... => 1,2,3,long task,4,5,6,...)\r\n        // In this case the duration will be longer\r\n        let isLongTaskBeforeRaf = (Math.abs(timestamp - performance.now()) /  this._duration) >  this._progressThreshold; //chrome check\r\n        let progress = ( timestamp -  this._lastUpdate ) /  this._duration; // e.g. 0.01\r\n        if ( progress >  this._progressThreshold ) isLongTaskBeforeRaf = true; // firefox check\r\n\r\n        if (isLongTaskBeforeRaf) deltaFrames = 1; // raf after long task, just move to the next frame\r\n        else { // normal execution, calculate progress after the last frame change\r\n            if (progress < 0) progress = 0; //it happens sometimes, when raf timestamp is from the past for some reason\r\n            deltaFrames = progress * this._data.totalImages; // Frame change step, e.g. 0.45 or 1.25\r\n            // e.g. progress is 0.8 frames, queue is 0.25 frames, so now deltaFrames is 1.05 frames and we need to update canvas,\r\n            // without this raf intervals will cause cumulative rounding errors, and actual fps will decrease\r\n            deltaFrames = deltaFrames +  this._framesQueue;\r\n        }\r\n\r\n        // calculate next frame only when we want to render\r\n        // if the getNextFrame check was outside, getNextFrame would be called at screen fps rate, not animation fps\r\n        // if screen fps 144 and animation fps 30, getNextFrame is calling now 30/s instead of 144/s.\r\n        // After the last frame, raf is repeating until the next frame calculation,\r\n        // between the last frame drawing and new frame time, reverse or loop could be changed, and animation won't stop\r\n        if ( deltaFrames >= 1) { // Calculate only if we need to update 1 frame or more\r\n            const newLastUpdate = isLongTaskBeforeRaf ? performance.now() : timestamp;\r\n\r\n            this._framesQueue = deltaFrames % 1; // save decimal part for the next RAFs\r\n            deltaFrames = Math.floor(deltaFrames) % this._data.totalImages;\r\n            if ( deltaFrames > this._framesLeftToPlay ) deltaFrames = this._framesLeftToPlay;// case when  animation fps > device fps\r\n            const newFrame = this._getNextFrame( deltaFrames );\r\n            if ( this._stopRequested ) { // animation ended from check in getNextFrame()\r\n                this._data.pluginApi.stop();\r\n                this._stopRequested = false;\r\n                if (this._data.pluginApi.getCurrentFrame() !== newFrame ) this._changeFrame(newFrame); //last frame fix if fps > device fps\r\n            } else { // animation is on\r\n                this._lastUpdate = newLastUpdate;\r\n                this._changeFrame(newFrame);\r\n                if (typeof this._framesLeftToPlay !== 'undefined') {\r\n                    this._framesLeftToPlay = this._framesLeftToPlay - deltaFrames;\r\n                    // if 0 frames left, stop immediately, don't wait for the next frame calculation\r\n                    // because if isAnimating become true, this will be a new animation\r\n                    if ( this._framesLeftToPlay <= 0 ) this._data.pluginApi.stop();\r\n                }\r\n            }\r\n        }\r\n        if ( this._isAnimating ) requestAnimationFrame(this.#animate.bind(this));\r\n    }\r\n\r\n    /**\r\n     * Recalculate animation duration after fps or totalImages change\r\n     */\r\n    _updateDuration(){\r\n         this._duration =  this._data.totalImages / this._settings.fps  * 1000;\r\n    }\r\n}\r\n","import { eventPrefix } from \"./settings\";\r\n\r\nexport default class Poster{\r\n    // Internal\r\n    _imageObject;\r\n    _isPosterLoaded;\r\n\r\n    constructor({settings, data, drawFrame}) {\r\n        this._settings = settings;\r\n        this._data = data;\r\n        this._drawFrame = drawFrame;\r\n\r\n        this._isPosterLoaded = false;\r\n    }\r\n\r\n    /**\r\n     * Start loading poster, then  show if needed\r\n     */\r\n    _loadAndShowPoster(){\r\n        if (this._settings.poster && !this._data.isAnyFrameChanged) {\r\n            this._imageObject = new Image();\r\n            this._imageObject.onload = this._imageObject.onerror = this.#onPosterLoaded.bind(this);\r\n            this._imageObject.src = this._settings.poster;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Redraw poster after canvas change if the poster was loaded\r\n     */\r\n    _redrawPoster(){\r\n        if ( this._data.isAnyFrameChanged || !this._isPosterLoaded ) return;\r\n        this.#drawPoster();\r\n    }\r\n\r\n    #onPosterLoaded(e){\r\n        if (e.type === \"error\") return;\r\n        this._isPosterLoaded = true;\r\n        this._data.canvas.element.dispatchEvent( new Event(eventPrefix + 'poster-loaded') );\r\n        this._settings.onPosterLoaded(this._data.pluginApi);\r\n        // show only if there wasn't any frame change from initial\r\n        // if poster loaded after all the images and any action, it won't be shown\r\n        if ( !this._data.isAnyFrameChanged ) {\r\n            this.#drawPoster();\r\n        }\r\n    }\r\n\r\n    #drawPoster(){\r\n        this._drawFrame(this._imageObject);\r\n    }\r\n}\r\n","import { eventPrefix } from \"./settings\";\r\n\r\nexport default class DragInput{\r\n    // Public\r\n    _isSwiping = false;\r\n\r\n    // Internal\r\n    _curX;\r\n    _curY;\r\n    _prevX;\r\n    _prevY;\r\n    _threshold;\r\n    _pixelsCorrection;\r\n    _lastInteractionTime;\r\n    _prevDirection;\r\n\r\n    constructor({ data, settings, changeFrame, getNextFrame }) {\r\n        this._data = data;\r\n        this._settings = settings;\r\n        this._changeFrame = changeFrame;\r\n        this._getNextFrame = getNextFrame;\r\n\r\n        this._SWIPE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'touchstart', 'touchmove', 'touchend', 'touchcancel'];\r\n        this._isSwiping = false;\r\n        this._boundSwipeHandler = this.#swipeHandler.bind(this);\r\n        this._pixelsCorrection = 0;\r\n\r\n        this._updateThreshold();\r\n    }\r\n\r\n    /**\r\n     * Enable rotating by mouse or touch drag\r\n     */\r\n    _enableDrag(){\r\n        this._SWIPE_EVENTS.forEach( (value) => {\r\n            this._data.canvas.element.addEventListener(value, this._boundSwipeHandler);\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Disable rotating by mouse or touch drag\r\n     */\r\n    _disableDrag(){\r\n        this._SWIPE_EVENTS.forEach( (value) => {\r\n            this._data.canvas.element.removeEventListener(value, this._boundSwipeHandler);\r\n        })\r\n        // if disabling while swipeMove is running\r\n        document.removeEventListener('mouseup', this._boundSwipeHandler);\r\n        document.removeEventListener('mousemove', this._boundSwipeHandler);\r\n        this._data.canvas.element.style.cursor = null;\r\n    }\r\n\r\n    /**\r\n     * Update one frame threshold in pixels\r\n     * @param newValue\r\n     */\r\n    _updateThreshold(newValue = null){\r\n        if (newValue) {\r\n            this._threshold = newValue;\r\n        }\r\n        else {\r\n            this._threshold = this._data.canvas.element.clientWidth / this._data.totalImages;\r\n        }\r\n    }\r\n\r\n\r\n    #swipeHandler(event) {\r\n        // get current click/touch point\r\n        let touches;\r\n        if ( event.touches !== undefined && event.touches.length ) touches = event.touches;\r\n        this._curX = (touches) ? touches[0].pageX : event.clientX;\r\n        this._curY = (touches) ? touches[0].pageY : event.clientY;\r\n\r\n        switch (event.type){\r\n            case 'mousedown': // start\r\n            case 'touchstart':\r\n                if ( event.type === 'touchstart' && event.cancelable ) {\r\n                    //event.preventDefault();\r\n                    this.#maybeDisableScroll(event);\r\n                }\r\n                document.addEventListener('mouseup', this._boundSwipeHandler); // move outside of the canvas\r\n                document.addEventListener('mousemove', this._boundSwipeHandler);\r\n                this.#swipeStart();\r\n                break;\r\n            case 'mousemove':\r\n            case 'touchmove': //move\r\n                // ignore mousemove without move (to prevent fake \"left\" movement)\r\n                const wasMoved = (this._prevX !== this._curX && this._prevY !== this._curX);\r\n                if ( this._isSwiping && wasMoved) {\r\n                    //if ( event.type === 'touchmove' && event.cancelable) event.preventDefault();\r\n                    this.#swipeMove();\r\n                }\r\n                break;\r\n            case 'mouseup':\r\n            case 'touchend':\r\n            case 'touchcancel': // end\r\n                //if ( (event.type === 'touchend' || event.type === 'touchcancel') && event.cancelable) event.preventDefault();\r\n                if ( this._isSwiping ) {\r\n                    document.removeEventListener('mouseup', this._boundSwipeHandler);\r\n                    document.removeEventListener('mousemove', this._boundSwipeHandler);\r\n                    this.#swipeEnd();\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    #swipeStart(){\r\n        const plugin = this._data.pluginApi;\r\n        if ( !(plugin.isFastPreloadFinished() || plugin.isPreloadFinished()) ) return;\r\n        // trigger full load after user interaction after fast preload finished\r\n        if (this._settings.fastPreview && !plugin.isPreloadFinished() && plugin.isFastPreloadFinished()) {\r\n            plugin.preloadImages();\r\n        }\r\n        plugin.stop();\r\n        this._isSwiping = true;\r\n        this._data.canvas.element.style.cursor = 'grabbing';\r\n        this._prevX = this._curX;\r\n        this._prevY = this._curY;\r\n        this._data.canvas.element.dispatchEvent( new CustomEvent(eventPrefix + 'drag-start',\r\n            { detail: {frame: this._data.currentFrame} })\r\n        );\r\n    }\r\n    #swipeMove(){\r\n        const direction = this.#swipeDirection();\r\n        if (this._prevDirection && this._prevDirection !== direction) { // reset after direction change\r\n            this._pixelsCorrection = 0;\r\n        }\r\n        this._prevDirection = direction;\r\n\r\n        const pixelDiffX = Math.abs(this._curX - this._prevX ); // save x diff before update\r\n        const swipeLength = (pixelDiffX + this._pixelsCorrection) * this._settings.dragModifier ;\r\n\r\n        this._prevX = this._curX; // update before any returns\r\n        this._prevY = this._curY; // update Y to prevent wrong angle after many vertical moves\r\n\r\n\r\n        if ( (direction !== 'left' && direction !== 'right') || // Ignore vertical directions\r\n            (swipeLength < this._threshold) ) { // Ignore if less than 1 frame\r\n            this._pixelsCorrection += pixelDiffX; // skip this mousemove, but save horizontal movement\r\n            return;\r\n        }\r\n\r\n\r\n        const progress = swipeLength / this._data.canvas.element.clientWidth; // full width swipe means full length animation\r\n        let deltaFrames = Math.floor(progress * this._data.totalImages);\r\n        deltaFrames = deltaFrames % this._data.totalImages;\r\n        // Add pixels to the next swipeMove if frames equivalent of swipe is not an integer number,\r\n        // e.g one frame is 10px, swipeLength is 13px, we change 1 frame and add 3px to the next swipe,\r\n        // so fullwidth swipe is always rotate sprite for 1 turn (with 'dragModifier' = 1).\r\n        // I divide the whole value by dragModifier because it seems to work as it should\r\n        this._pixelsCorrection = (swipeLength - (this._threshold * deltaFrames)) / this._settings.dragModifier;\r\n        let isReverse = (direction === 'left'); // left means backward (reverse: true)\r\n        if (this._settings.inversion) isReverse = !isReverse;// invert direction\r\n        this._changeFrame(this._getNextFrame( deltaFrames, isReverse )); // left means backward (reverse: true)\r\n        this._data.canvas.element.dispatchEvent( new CustomEvent(eventPrefix + 'drag-change',\r\n            { detail: {\r\n                frame: this._data.currentFrame,\r\n                direction,\r\n            } })\r\n        );\r\n    }\r\n    #swipeEnd(){\r\n        //if ( swipeObject.curX === undefined ) return; // there is no x coord on touch end\r\n        this._curX = this._curY = this._prevX = this._prevY = null;\r\n        this._isSwiping = false;\r\n        this._data.canvas.element.style.cursor = null;\r\n        this._lastInteractionTime = new Date().getTime();\r\n        this._data.canvas.element.dispatchEvent( new CustomEvent(eventPrefix + 'drag-end',\r\n            { detail: {\r\n                frame: this._data.currentFrame,\r\n                direction: this._prevDirection,\r\n            } })\r\n        );\r\n    }\r\n    #swipeDirection(){\r\n        let r, swipeAngle,\r\n            xDist = this._prevX - this._curX,\r\n            yDist = this._prevY - this._curY;\r\n\r\n        // taken from slick.js\r\n        r = Math.atan2(yDist, xDist);\r\n        swipeAngle = Math.round(r * 180 / Math.PI);\r\n        if (swipeAngle < 0) swipeAngle = 360 - Math.abs(swipeAngle);\r\n\r\n        if ( (swipeAngle >= 0 && swipeAngle <= 60) || (swipeAngle <= 360 && swipeAngle >= 300 )) return 'left';\r\n        else if ( swipeAngle >= 120 && swipeAngle <= 240 ) return 'right';\r\n        else if ( swipeAngle >= 241 && swipeAngle <= 299 ) return 'bottom';\r\n        else return 'up';\r\n    }\r\n\r\n    /**\r\n     * Idea from https://github.com/giniedp/spritespin/blob/master/src/plugins/input-drag.ts#L45\r\n     * @param {Event} event\r\n     */\r\n    #maybeDisableScroll(event){\r\n        // always prevent\r\n        if (this._settings.touchScrollMode === \"preventPageScroll\") event.preventDefault();\r\n        // check timer\r\n        if (this._settings.touchScrollMode === \"pageScrollTimer\") {\r\n            const now = new Date().getTime();\r\n            // less time than delay => prevent page scroll\r\n            if (this._lastInteractionTime && (now - this._lastInteractionTime < this._settings.pageScrollTimerDelay) ){\r\n                event.preventDefault();\r\n            } else { // more time than delay or first interaction => clear timer\r\n                this._lastInteractionTime = null;\r\n            }\r\n        }\r\n        // if touchScrollMode=\"allowPageScroll\" => don't prevent scroll\r\n    }\r\n}\r\n","import { normalizeFrameNumber, uppercaseFirstChar } from \"./utils\";\r\nimport { validateInitParameters, defaultSettings } from \"./settings\";\r\nimport ImagePreloader from \"./ImagePreloader\";\r\nimport Render from \"./Render\";\r\nimport Animation from \"./Animation\";\r\nimport Poster from \"./Poster\";\r\nimport DragInput from \"./DragInput\";\r\n\r\n/**\r\n * Animate Images {@link https://github.com/its2easy/animate-images/}\r\n * @example\r\n * let pluginInstance = new AnimateImages(document.querySelector('canvas'), {\r\n *    images: ['img1.jpg', 'img2.jpg', 'img3.jpg'],\r\n *    loop: true,\r\n *    draggable: true,\r\n *    fps: 60,\r\n * });\r\n */\r\nexport default class AnimateImages{\r\n    #settings;\r\n    #data = {\r\n        currentFrame: 1,\r\n        totalImages: null,\r\n        loadedImagesArray: [], // images objects [0 - (images.length-1)]\r\n        deferredAction: null, // call after full preload\r\n        isAnyFrameChanged: false,\r\n        /** @type AnimateImages */\r\n        pluginApi: undefined,\r\n        canvas: {\r\n            element: null,\r\n            ratio: null,\r\n        },\r\n    }\r\n    #boundUpdateCanvasSizes;\r\n    //Classes\r\n    #preloader;\r\n    #render;\r\n    #animation;\r\n    #poster;\r\n    #dragInput;\r\n\r\n    /**\r\n     * Creates plugin instance\r\n     * @param {HTMLCanvasElement} node - canvas element\r\n     * @param {PluginOptions} options\r\n     */\r\n    constructor(node, options){\r\n        validateInitParameters(node, options);\r\n        this.#settings = {...defaultSettings, ...options};\r\n        this.#data.totalImages = this.#settings.images.length;\r\n        this.#data.canvas.element = node;\r\n        this.#data.pluginApi = this;\r\n        this.#boundUpdateCanvasSizes = this.#updateCanvasSizes.bind(this)\r\n        this.#initPlugin();\r\n    }\r\n\r\n    #initPlugin(){\r\n        this.#render = new Render( {settings: this.#settings, data: this.#data} );\r\n        this.#animation = new Animation(\r\n            {settings: this.#settings, data: this.#data, changeFrame:  this.#changeFrame.bind(this)} );\r\n        this.#updateCanvasSizes();\r\n        if ( this.#settings.poster ) this.#setupPoster();\r\n        this.#toggleResizeHandler(true);\r\n        this.#preloader = new ImagePreloader({\r\n            settings: this.#settings,\r\n            data: this.#data,\r\n            updateImagesCount: this.#updateImagesCount.bind(this),\r\n            getFramesLeft: this.#getFramesLeft.bind(this),\r\n        });\r\n        if (this.#settings.preload === 'all' || this.#settings.preload === \"partial\"){\r\n            let preloadNumber = (this.#settings.preload === 'all') ? this.#data.totalImages : this.#settings.preloadNumber;\r\n            if (preloadNumber === 0) preloadNumber = this.#data.totalImages;\r\n            this.#preloader._startLoading(preloadNumber);\r\n        }\r\n        if (this.#settings.autoplay) this.play();\r\n        if ( this.#settings.draggable ) this.#toggleDrag(true);\r\n    }\r\n\r\n    #changeFrame(frameNumber){\r\n        if (frameNumber === this.#data.currentFrame && this.#data.isAnyFrameChanged) return;//skip same frame, except first drawing\r\n        if ( !this.#data.isAnyFrameChanged ) this.#data.isAnyFrameChanged = true;\r\n\r\n        this.#animateCanvas(frameNumber);\r\n        this.#data.currentFrame = frameNumber;\r\n    }\r\n\r\n    #animateCanvas(frameNumber){\r\n        this.#render._clearCanvas();\r\n        this.#render._drawFrame( this.#data.loadedImagesArray[frameNumber - 1] );\r\n    }\r\n\r\n\r\n    #updateCanvasSizes(){\r\n        const canvas = this.#data.canvas;\r\n        /**\r\n         * +++RATIO SECTION+++\r\n         * If no options.ratio, inline canvas width/height will be used (2:1 if not set)\r\n         * Real canvas size is controlled by CSS, inner size will be set based on CSS width and ratio (height should be \"auto\")\r\n         * If height if fixed in CSS, ratio can't be used and inner height will be equal to CSS-defined height\r\n         */\r\n        if ( this.#settings.ratio ) canvas.ratio = this.#settings.ratio;\r\n        // Initial ratio shouldn't be changed. Ratio will only modified after setOption(\"ratio\", newRatio),\r\n        // or after setting css height and plugin.updateCanvas()\r\n        else if ( !canvas.ratio ) {\r\n            canvas.ratio = canvas.element.width / canvas.element.height;\r\n        }\r\n\r\n\r\n        // +++SIZE SECTION+++\r\n        // mainSide is the side from responsiveAspect, it should be controlled by CSS, secondarySide value will be\r\n        // controlled by script\r\n        const dpr = (window.devicePixelRatio).toFixed(2) || 1; // sometimes dpr is like 2.00000000234\r\n        let mainSide = this.#settings.responsiveAspect;// width or height\r\n        let clientMainSide =  \"client\" + uppercaseFirstChar(mainSide); // clientWidth or clientHeight\r\n        let secondarySide = (mainSide === \"width\") ? \"height\" : \"width\";\r\n        let clientSecondarySide = \"client\" + uppercaseFirstChar(secondarySide);// clientWidth or clientHeight\r\n\r\n        // changing width and height won't change real clientWidth and clientHeight if size is fixed by CSS\r\n        const initialClientMainSide = canvas.element[clientMainSide];\r\n        canvas.element[mainSide] = canvas.element[clientMainSide] * dpr;\r\n\r\n        // !!! ONLY if dpr != 1 and canvas css mainSide was not defined => changed width will change clientWidth\r\n        // so we need to recalculate width based on new clientWidth\r\n        if (initialClientMainSide !== canvas.element[clientMainSide]) {\r\n            canvas.element[mainSide] = canvas.element[clientMainSide] * dpr;\r\n        }\r\n\r\n        let rawNewValue = (mainSide === \"width\") ? canvas.element.clientWidth / canvas.ratio : canvas.element.clientHeight * canvas.ratio;\r\n        canvas.element[secondarySide] = Math.round(rawNewValue) * dpr; // \"round\" for partial fix to rounding pixels error\r\n\r\n\r\n        // +++CORRECTION SECTION+++\r\n        const secondaryValueDifference = Math.abs(canvas.element[secondarySide] - canvas.element[clientSecondarySide] * dpr);// diff in pixels\r\n        // previously I compared with 1px to check subpixel errors, but error is somehow related to dpr, so we compare with \"1px * dpr\" or just \"dpr\"\r\n        if ( secondaryValueDifference > dpr) { // if secondarySide is locked by CSS\r\n            let newRatio = canvas.element.clientWidth / canvas.element.clientHeight; // ratio from \"real\" canvas element\r\n            // <1% change => calculation error; >1% change => secondarySide size is locked with css\r\n            if ( Math.abs(canvas.ratio - newRatio) / canvas.ratio > 0.01 ) {\r\n                canvas.element[secondarySide] = canvas.element[clientSecondarySide] * dpr;\r\n                canvas.ratio = newRatio;\r\n            } else { // small diff between inner and real values, adjust to prevent errors accumulation\r\n                canvas.element[secondarySide] = (mainSide === \"width\") ? canvas.element.width / canvas.ratio : canvas.element.height * canvas.ratio;\r\n            }\r\n        } else if (secondaryValueDifference > 0 && secondaryValueDifference <= dpr ) { // rare case, pixels are fractional\r\n            // so just update inner canvas size baser on main side and ratio\r\n            canvas.element[secondarySide] = (mainSide === \"width\") ? canvas.element.width / canvas.ratio : canvas.element.height * canvas.ratio;\r\n        }\r\n\r\n        if ( this.#dragInput ) this.#dragInput._updateThreshold()\r\n        this.#maybeRedrawFrame(); // canvas is clear after resize\r\n    }\r\n\r\n    #updateImagesCount(){\r\n        if ( this.#dragInput ) this.#dragInput._updateThreshold();\r\n        this.#animation._updateDuration();\r\n    }\r\n    #maybeRedrawFrame(){\r\n        if ( this.#data.isAnyFrameChanged ) { // frames were drawn\r\n            this.#animateCanvas(this.#data.currentFrame);\r\n        } else if ( this.#poster ) { // poster exists\r\n            this.#poster._redrawPoster();\r\n        }\r\n        // don't redraw in initial state, or if poster onLoad is not finished yet\r\n    }\r\n\r\n    #toggleDrag(enable){\r\n        if (enable) {\r\n            if ( !this.#dragInput ) this.#dragInput = new DragInput({\r\n                data: this.#data,\r\n                settings: this.#settings,\r\n                changeFrame: this.#changeFrame.bind(this),\r\n                getNextFrame: this.#animation._getNextFrame.bind(this.#animation)\r\n            });\r\n            this.#dragInput._enableDrag();\r\n        } else {\r\n            if (this.#dragInput) this.#dragInput._disableDrag();\r\n        }\r\n    }\r\n\r\n    #setupPoster(){\r\n        if (!this.#poster) this.#poster = new Poster(\r\n            {\r\n                settings: this.#settings,\r\n                data: this.#data,\r\n                drawFrame: this.#render._drawFrame.bind(this.#render)\r\n            });\r\n        this.#poster._loadAndShowPoster();\r\n    }\r\n\r\n    #toggleResizeHandler(add = true) {\r\n        if ( add ) window.addEventListener(\"resize\", this.#boundUpdateCanvasSizes);\r\n        else window.removeEventListener(\"resize\", this.#boundUpdateCanvasSizes);\r\n    }\r\n\r\n    #getFramesLeft(){\r\n        return this.#animation._framesLeftToPlay;\r\n    }\r\n\r\n    // Pubic API\r\n\r\n    /**\r\n     * Start animation\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    play(){\r\n        if ( this.#animation._isAnimating ) return this;\r\n        if ( this.#preloader._isAnyPreloadFinished ) {\r\n            this.#animation._play();\r\n            this.#preloader._maybePreloadAll();\r\n        } else {\r\n            this.#data.deferredAction = this.play.bind(this);\r\n            this.#preloader._startLoading();\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Stop animation\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    stop(){\r\n        this.#animation._stop();\r\n        return this;\r\n    }\r\n    /**\r\n     * Toggle between start and stop\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    toggle(){\r\n        if ( !this.#animation._isAnimating ) this.play();\r\n        else this.stop();\r\n        return this;\r\n    }\r\n    /**\r\n     * Show next frame\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    next(){\r\n        if ( this.#preloader._isAnyPreloadFinished ) {\r\n            this.stop();\r\n            this.#changeFrame( this.#animation._getNextFrame(1) );\r\n            this.#preloader._maybePreloadAll();\r\n        } else {\r\n            this.#data.deferredAction = this.next.bind(this);\r\n            this.#preloader._startLoading();\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Show previous frame\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    prev(){\r\n        if ( this.#preloader._isAnyPreloadFinished ) {\r\n            this.stop();\r\n            this.#changeFrame( this.#animation._getNextFrame(1, !this.#settings.reverse) );\r\n            this.#preloader._maybePreloadAll();\r\n        } else {\r\n            this.#data.deferredAction = this.prev.bind(this);\r\n            this.#preloader._startLoading();\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Show a frame with a specified number (without animation)\r\n     * @param {number} frameNumber - Number of the frame to show\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    setFrame(frameNumber){\r\n        if ( this.#preloader._isAnyPreloadFinished ) {\r\n            this.stop();\r\n            this.#changeFrame(normalizeFrameNumber(frameNumber, this.#data.totalImages));\r\n            this.#preloader._maybePreloadAll();\r\n        } else {\r\n            this.#data.deferredAction = this.setFrame.bind(this, frameNumber);\r\n            this.#preloader._startLoading();\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Start animation, that plays until the specified frame number\r\n     * @param {number} frameNumber - Target frame number\r\n     * @param {Object} [options] - Options\r\n     * @param {boolean} [options.shortestPath=false] - If set to true and loop enabled, will use the shortest path\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    playTo(frameNumber, options){\r\n        frameNumber = normalizeFrameNumber(frameNumber, this.#data.totalImages);\r\n\r\n        const innerPathDistance = Math.abs(frameNumber - this.#data.currentFrame), // not crossing edge frames\r\n            outerPathDistance = this.#data.totalImages - innerPathDistance, // crossing edges frames\r\n            shouldUseOuterPath = this.#settings.loop && options?.shortestPath && (outerPathDistance < innerPathDistance);\r\n\r\n        if ( !shouldUseOuterPath ) { // Inner path (default)\r\n            // long conditions to make them more readable\r\n            if (frameNumber > this.#data.currentFrame) this.setReverse(false); // move forward\r\n            else this.setReverse(true); // move backward\r\n        } else { // Outer path\r\n            if (frameNumber < this.#data.currentFrame) this.setReverse(false); // move forward\r\n            else this.setReverse(true); // move backward\r\n        }\r\n\r\n        return this.playFrames( (shouldUseOuterPath) ? outerPathDistance : innerPathDistance );\r\n    }\r\n    /**\r\n     * Start animation in the current direction with the specified number of frames in the queue\r\n     * @param {number} [numberOfFrames=0] - Number of frames to play\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    playFrames(numberOfFrames = 0){\r\n        if ( this.#preloader._isAnyPreloadFinished ) {\r\n            numberOfFrames = Math.floor(numberOfFrames);\r\n            if (numberOfFrames < 0) { // first frame should be rendered to replace poster or transparent bg, so allow 0 for the first time\r\n                return this.stop(); //empty animation, stop() to trigger events and callbacks\r\n            }\r\n\r\n            // if this is the 1st animation, we should add 1 frame to the queue to draw the 1st initial frame\r\n            // because 1st frame is not drawn by default (1 frame will replace poster or transparent bg)\r\n            if (!this.#data.isAnyFrameChanged) numberOfFrames += 1;\r\n            if (numberOfFrames <= 0) { // with playFrames(0) before any actions numberOfFrames=1, after any frame change numberOfFrames=0\r\n                return this.stop(); //empty animation\r\n            }\r\n\r\n            this.#animation._framesLeftToPlay = numberOfFrames;\r\n            this.play();\r\n            this.#preloader._maybePreloadAll();\r\n        } else {\r\n            this.#data.deferredAction = this.playFrames.bind(this, numberOfFrames);\r\n            this.#preloader._startLoading();\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Change the direction of the animation. Alias to <b>setOption('reverse', true)</b>\r\n     * @param {boolean} [reverse=true] - true for backward animation, false for forward, default \"true\"\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    setReverse(reverse = true){\r\n        this.#settings.reverse = !!reverse;\r\n        return this;\r\n    }\r\n    /**\r\n     * Get current reverse option. Alias to <b>getOption('reverse')</b>\r\n     * @returns {boolean} - reverse or not\r\n     */\r\n    getReverse() { return this.#settings.reverse; }\r\n    /**\r\n     * Change the direction of the animation. It does the opposite effect of <b>setReverse()</b>\r\n     * @param {boolean} [forward=true] - true for forward animation, false for backward, default \"true\"\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    setForward(forward = true){\r\n        this.#settings.reverse = !forward;\r\n        return this;\r\n    }\r\n    /**\r\n     * Start preload specified number of images, can be called multiple times.\r\n     * If all the images are already loaded, then nothing will happen\r\n     * @param {number} number - Number of images to load. If not specified, all remaining images will be loaded.\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    preloadImages(number= undefined){\r\n        number = number ?? this.#settings.images.length;\r\n        this.#preloader._startLoading(number);\r\n        return this;\r\n    }\r\n    /**\r\n     * Calculate new canvas dimensions. Should be called after the canvas size was changed manually\r\n     * Called automatically after page resize\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    updateCanvas(){\r\n        this.#updateCanvasSizes();\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns option value\r\n     * @param {string} option - Option name. All options are allowed\r\n     * @returns {*} - Current option value\r\n     */\r\n    getOption(option){\r\n        if ( option in this.#settings ) {\r\n            return this.#settings[option];\r\n        } else {\r\n            console.warn(`${option} is not a valid option`);\r\n        }\r\n    }\r\n    /**\r\n     * Set new option value\r\n     * @param {string} option - Option name. Allowed options: fps, loop, reverse, inversion, ratio, fillMode, draggable, dragModifier,\r\n     * touchScrollMode, pageScrollTimerDelay, onPreloadFinished, onPosterLoaded, onAnimationEnd, onBeforeFrame, onAfterFrame\r\n     * @param {*} value - New value\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    setOption(option, value) {\r\n        const allowedOptions = ['fps', 'loop', 'reverse', 'inversion', 'ratio', 'fillMode', 'draggable', 'dragModifier', 'touchScrollMode',\r\n            'pageScrollTimerDelay', 'onPreloadFinished', 'onFastPreloadFinished', 'onPosterLoaded', 'onAnimationEnd', 'onBeforeFrame', 'onAfterFrame'];\r\n        if (allowedOptions.includes(option)) {\r\n           this.#settings[option] = value;\r\n           if (option === 'fps') this.#animation._updateDuration();\r\n           if (option === 'ratio') this.#updateCanvasSizes();\r\n           if (option === 'fillMode') this.#updateCanvasSizes();\r\n           if (option === 'draggable') this.#toggleDrag(value);\r\n           if (option === 'dragModifier') this.#settings.dragModifier = Math.abs(+value);\r\n        } else {\r\n            console.warn(`${option} is not allowed in setOption`);\r\n        }\r\n        return this;\r\n    }\r\n    /** @returns {number} - current frame number */\r\n    getCurrentFrame() { return this.#data.currentFrame }\r\n    /** @returns {number} - total frames (considering loading errors) */\r\n    getTotalImages() { return this.#data.totalImages }\r\n    /** @returns {number} - current canvas ratio */\r\n    getRatio() { return this.#data.canvas.ratio }\r\n    /** @returns {boolean} - animating or not */\r\n    isAnimating() { return this.#animation._isAnimating }\r\n    /** @returns {boolean} - returns true if a drag action is in progress */\r\n    isDragging() {\r\n        if ( this.#dragInput ) return this.#dragInput._isSwiping;\r\n        return false\r\n    }\r\n    /** @returns {boolean} - is preload finished */\r\n    isPreloadFinished() { return this.#preloader._isPreloadFinished }\r\n    /** @returns {boolean} - is fast preview mode preload finished */\r\n    isFastPreloadFinished() { return this.#preloader._isFastPreloadFinished }\r\n    /** @returns {boolean} - is loaded with errors */\r\n    isLoadedWithErrors() { return this.#preloader._isLoadedWithErrors }\r\n\r\n    /**\r\n     * Stop the animation and return to the first frame\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    reset(){\r\n        if ( this.#preloader._isAnyPreloadFinished ) {\r\n            this.stop();\r\n            this.#changeFrame(normalizeFrameNumber(1, this.#data.totalImages));\r\n            this.#preloader._maybePreloadAll();\r\n        } else {\r\n            this.#data.deferredAction = this.reset.bind(this);\r\n            this.#preloader._startLoading();\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Stop animation, remove event listeners and clear the canvas. Method doesn't remove canvas element from the DOM\r\n     */\r\n    destroy(){\r\n        this.stop();\r\n        this.#render._clearCanvas();\r\n        this.#toggleDrag(false);\r\n        this.#toggleResizeHandler(false);\r\n    }\r\n}\r\n/**\r\n * NOTE\r\n * All internal classes have public methods and properties start with _, that's for terser plugin that can mangle internal names\r\n * by regexp. It's reducing size by about 20%. Private (#) properties are not used in internal classes because babel use wrapper\r\n * functions for these properties, which increases the size even though private names are minified\r\n */\r\n\r\n/**\r\n * @typedef {Object} PluginOptions\r\n * @property {Array<string>} images - Array with images URLs (required)\r\n * @property {'all'|'partial'|'none'} [preload=\"all\"] - Preload mode (\"all\", \"none\", \"partial\")\r\n * @property {number} [preloadNumber=0] - Number of preloaded images when <b>preload: \"partial\"</b>, 0 for all\r\n * @property {string} [poster] - Url of a poster image, to show before load\r\n * @property {number} [fps=30] - FPS when playing. Determines the duration of the animation (for example 90 images and 60\r\n * fps = 1.5s, 90 images and 30fps = 3s)\r\n * @property {boolean} [loop=false] - Loop the animation\r\n * @property {boolean} [autoplay=false] - Autoplay\r\n * @property {boolean} [reverse=false] - Reverse direction\r\n * reverse means forward or backward, and inversion determines which direction is forward. Affects animation and drag\r\n * @property {number} [ratio] - Canvas width/height ratio, it has higher priority than inline canvas width and height\r\n * @property {'cover'|'contain'} [fillMode=\"cover\"] - Fill mode to use if canvas and image aspect ratios are different\r\n * (\"cover\" or \"contain\")\r\n * @property {boolean} [draggable=false] - Draggable by mouse or touch\r\n * @property {boolean} [inversion=false] - Inversion changes drag direction\r\n * @property {number} [dragModifier=1] - Sensitivity factor for user interaction. Only positive numbers are allowed\r\n * @property {'pageScrollTimer' | 'preventPageScroll' | 'allowPageScroll'} [touchScrollMode = \"pageScrollTimer\"] - Page\r\n * scroll behavior with touch events (preventPageScroll,allowPageScroll, pageScrollTimer)\r\n * @property {number} [pageScrollTimerDelay=1500] - Time in ms when touch scroll will be disabled during interaction\r\n * if <b>touchScrollMode: \"pageScrollTimer\"<b>\r\n * @property {'width'|'height'} [responsiveAspect=\"width\"] - Which side will be responsive (controlled by css)\r\n * @property {Object|false} [fastPreview=false] - Special mode for interactivity after loading only a part of the pictures\r\n * @property {Array<string>} [fastPreview.images] - images urls for fastPreview mode (<b>Required</b> if fastPreview is enabled)\r\n * @property {number} [fastPreview.fpsAfter] - fps value that will be applied after the full list of images is loaded\r\n * @property {function(number):number} [fastPreview.matchFrame] - A function that takes the frame number of the short set\r\n * and returns the frame number of the full set, to prevent jump after full load.\r\n * @property {function(AnimateImages):void} [onPreloadFinished] - Occurs when all image files have been loaded\r\n * @property {function(AnimateImages):void} [onFastPreloadFinished] - Occurs when all fastPreview mode images have been loaded\r\n * @property {function(AnimateImages):void} [onPosterLoaded] - Occurs when poster image is fully loaded\r\n * @property {function(AnimateImages):void} [onAnimationEnd] - Occurs when animation has ended\r\n * @property {function(AnimateImages, FrameInfo):void} [onBeforeFrame] - Occurs before new frame\r\n * @property {function(AnimateImages, FrameInfo):void} [onAfterFrame] - Occurs after the frame was drawn\r\n */\r\n\r\n/**\r\n * @typedef {Object} FrameInfo\r\n * @property {CanvasRenderingContext2D} context - canvas context\r\n * @property {number} width - internal canvas width\r\n * @property {number} height - internal canvas height\r\n * */\r\n"],"names":["normalizeFrameNumber","frameNumber","totalImages","Math","floor","uppercaseFirstChar","word","charAt","toUpperCase","slice","defaultSettings","preload","preloadNumber","poster","fps","loop","autoplay","reverse","ratio","undefined","fillMode","draggable","inversion","dragModifier","touchScrollMode","pageScrollTimerDelay","responsiveAspect","fastPreview","onFastPreloadFinished","noOp","onPreloadFinished","onPosterLoaded","onAnimationEnd","onBeforeFrame","onAfterFrame","eventPrefix","ImagePreloader","constructor","settings","data","updateImagesCount","getFramesLeft","this","_settings","_data","_updateImagesCount","_getFramesLeft","_isPreloadFinished","_isFastPreloadFinished","_isAnyPreloadFinished","_isLoadedWithErrors","_preloadOffset","_preloadedCount","_tempImagesArray","_failedImages","_currentMode","_modes","default","images","event","callback","fast","TypeError","length","_totalImages","_startLoading","round","unloadedCount","i","img","Image","onload","onerror","onImageLoad","bind","src","e","progress","canvas","element","dispatchEvent","CustomEvent","detail","type","path","composedPath","push","Event","clearImagesArray","afterPreloadFinishes","filter","el","includes","loadedImagesArray","savedMode","plugin","pluginApi","deferredAction","fpsAfter","setOption","wasAnimating","isAnimating","framesAreInQueue","matchFrame","setFrame","currentFrame","play","_maybePreloadAll","Render","_context","getContext","_drawFrame","imageObject","sx","sy","sWidth","sHeight","dx","dy","dWidth","dHeight","getDrawImageCoverProps","getDrawImageContainProps","canvasEl","context","width","height","drawImage","_clearCanvas","clearRect","image","canvasWidth","canvasHeight","imageWidth","naturalWidth","imageHeight","naturalHeight","minRatio","min","newWidth","newHeight","ar","abs","ratioX","ratioY","minRation","Animation","_isAnimating","_framesLeftToPlay","_lastUpdate","_duration","_stopRequested","_framesQueue","_progressThreshold","changeFrame","_changeFrame","_updateDuration","_play","isAnyFrameChanged","Number","isFinite","requestAnimationFrame","animate","_stop","_getNextFrame","deltaFrames","newFrameNumber","timestamp","performance","now","isLongTaskBeforeRaf","newLastUpdate","newFrame","stop","getCurrentFrame","Poster","_imageObject","_isPosterLoaded","drawFrame","_loadAndShowPoster","_redrawPoster","drawPoster","DragInput","_isSwiping","_curX","_curY","_prevX","_prevY","_threshold","_pixelsCorrection","_lastInteractionTime","_prevDirection","getNextFrame","_SWIPE_EVENTS","_boundSwipeHandler","swipeHandler","_updateThreshold","_enableDrag","forEach","value","addEventListener","_disableDrag","removeEventListener","document","style","cursor","newValue","clientWidth","touches","pageX","clientX","pageY","clientY","cancelable","maybeDisableScroll","swipeStart","wasMoved","swipeMove","swipeEnd","isFastPreloadFinished","isPreloadFinished","preloadImages","frame","direction","swipeDirection","pixelDiffX","swipeLength","isReverse","Date","getTime","r","swipeAngle","xDist","yDist","atan2","PI","preventDefault","AnimateImages","boundUpdateCanvasSizes","preloader","render","animation","dragInput","node","options","HTMLCanvasElement","Array","isArray","parseInt","validateInitParameters","updateCanvasSizes","initPlugin","setupPoster","toggleResizeHandler","toggleDrag","animateCanvas","dpr","window","toFixed","mainSide","clientMainSide","secondarySide","clientSecondarySide","initialClientMainSide","rawNewValue","clientHeight","secondaryValueDifference","newRatio","maybeRedrawFrame","enable","add","toggle","next","prev","playTo","innerPathDistance","outerPathDistance","shouldUseOuterPath","shortestPath","setReverse","playFrames","numberOfFrames","getReverse","setForward","forward","number","updateCanvas","getOption","option","console","warn","getTotalImages","getRatio","isDragging","isLoadedWithErrors","reset","destroy"],"mappings":"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"}