{"version":3,"file":"animate-images.esm.min.js","sources":["../src/utils.js","../src/settings.js","../src/ImagePreloader.js","../src/Render.js","../src/Animation.js","../src/Poster.js","../src/DragInput.js","../src/AnimateImages.js"],"sourcesContent":["export function normalizeFrameNumber(frameNumber, totalImages){\r\n    frameNumber = Math.floor(frameNumber);\r\n    if (frameNumber <= 0) {\r\n        return 1;\r\n    } else if (frameNumber > totalImages) {\r\n        return totalImages;\r\n    }\r\n    return frameNumber;\r\n}\r\n\r\nexport function calculateFullAnimationDuration(imagesNumber, fps){\r\n    return imagesNumber / fps  * 1000;\r\n}\r\n\r\nexport function uppercaseFirstChar(word){\r\n    return word.charAt(0).toUpperCase() + word.slice(1);\r\n}","export function validateInitParameters(node, options){\r\n    if ( !(node instanceof HTMLCanvasElement) ) { // Check dom node\r\n        throw new TypeError('node is required and should be canvas element');\r\n    }\r\n    if (!options.images || !Array.isArray(options.images) || options.images.length <= 1 ) { // Check images list\r\n        throw new TypeError('options.images is required and must be an array with more than 1 element');\r\n    }\r\n    // if ( (\"preload\" in options) && // Check preload type\r\n    //     (\r\n    //         !(typeof options.preload  === \"string\")\r\n    //         || !(options.preload === \"all\" || options.preload === \"none\" || options.preload === \"partial\")\r\n    //     )\r\n    // ) {\r\n    //     throw new TypeError('options.preload must be one of these: all, none, partial');\r\n    // }\r\n    // if ( (\"preloadNumber\" in options)\r\n    //     && !( Number.isInteger(Number.parseInt(options.preloadNumber)) && Number.parseInt(options.preloadNumber) >= 0 )\r\n    // ) {\r\n    //     throw new TypeError('options.preloadNumber must be number >= 0');\r\n    // }\r\n    if ('preloadNumber' in options) options.preloadNumber = Number.parseInt(options.preloadNumber); // Allow number as a string\r\n    if (\"fillMode\" in options && !['cover', 'contain'].includes(options.fillMode))  delete options['fillMode'];\r\n    if ('dragModifier' in options) options.dragModifier = Math.abs(+options.dragModifier);\r\n}\r\n\r\nexport const defaultSettings = {\r\n    preload: \"all\",\r\n    preloadNumber: 0,\r\n    poster: false,\r\n    fps: 30,\r\n    loop: false,\r\n    autoplay: false,\r\n    reverse: false,\r\n    ratio: undefined,\r\n    fillMode: \"cover\",\r\n\r\n    draggable: false,\r\n    inversion: false,\r\n    dragModifier: 1,\r\n    touchScrollMode: \"pageScrollTimer\",\r\n    pageScrollTimerDelay: 1500,\r\n    responsiveAspect: \"width\",\r\n\r\n    fastPreview: false,\r\n\r\n    onFastPreloadFinished: noOp,\r\n    onPreloadFinished: noOp,\r\n    onPosterLoaded: noOp,\r\n    onAnimationEnd: noOp,\r\n    onBeforeFrame: noOp,\r\n    onAfterFrame: noOp,\r\n}\r\n\r\nexport const eventPrefix = \"animate-images:\";\r\n\r\nfunction noOp(){}\r\n","import { eventPrefix } from \"./settings\";\r\n\r\nexport default class ImagePreloader{\r\n\r\n    constructor( {settings, data, updateImagesCount, getFramesLeft} ) {\r\n        this._settings = settings;\r\n        this._data = data;\r\n        this._updateImagesCount = updateImagesCount;\r\n        this._getFramesLeft = getFramesLeft;\r\n\r\n        // Public\r\n        this._isPreloadFinished = false;// onload on all the images\r\n        this._isFastPreloadFinished = false;// images from fastPreload mode\r\n        this._isAnyPreloadFinished = false;\r\n        this._isLoadedWithErrors = false;\r\n\r\n        // Internal\r\n        this._preloadOffset = 0;// images already in queue\r\n        this._preloadedCount = 0;// count of loaded images\r\n        this._tempImagesArray = []; // store images before they are fully loaded\r\n        this._failedImages = [];\r\n        this._currentMode = \"default\";// \"default\" or \"fast\"\r\n        this._modes = {\r\n            default: {\r\n                images: this._settings.images,\r\n                event: eventPrefix + \"preload-finished\",\r\n                callback: this._settings.onPreloadFinished,\r\n            },\r\n            fast: {\r\n                images: this._settings?.fastPreview.images,\r\n                event: eventPrefix + \"fast-preload-finished\",\r\n                callback: this._settings.onFastPreloadFinished,\r\n            }\r\n        }\r\n\r\n        // set mode if fast preview\r\n        if (this._settings.fastPreview) {\r\n            if ( !this._settings.fastPreview.images ) {\r\n                throw new TypeError('fastPreview.images is required when fastPreview is enabled');\r\n            }\r\n            this._currentMode = \"fast\";\r\n            this._data.totalImages = this._settings.fastPreview.images.length;\r\n        }\r\n        this._totalImages = this._data.totalImages; // get initial value for the first time, update when fast => default mode\r\n    }\r\n\r\n    /**\r\n     * Add number of images to loading queue\r\n     * @param {number} [preloadNumber] - number of images to load\r\n     */\r\n    _startLoading(preloadNumber){\r\n        if (this._isPreloadFinished) return;\r\n        if ( !preloadNumber ) preloadNumber = this._totalImages;\r\n        preloadNumber = Math.round(preloadNumber);\r\n\r\n        // if too many, load just the rest\r\n        const unloadedCount = this._totalImages - this._preloadOffset;\r\n        if (preloadNumber > unloadedCount){\r\n            preloadNumber = unloadedCount;\r\n        }\r\n\r\n        // true when all the images are in queue but not loaded yet, (unloadedCount = preloadNumber = 0)\r\n        if (preloadNumber <= 0) return;\r\n\r\n        //console.log(`start loop, preloadNumber=${preloadNumber}, offset=${this._preloadOffset}`);\r\n        for (let i = this._preloadOffset; i < (preloadNumber + this._preloadOffset); i++){\r\n            let img = new Image();\r\n            img.onload = img.onerror = this.#onImageLoad.bind(this);\r\n            img.src = this._modes[this._currentMode].images[i]\r\n            this._tempImagesArray[i] = img;\r\n        }\r\n        this._preloadOffset = this._preloadOffset + preloadNumber;\r\n    }\r\n\r\n    #onImageLoad(e){\r\n        this._preloadedCount++;\r\n        const progress = Math.floor((this._preloadedCount/this._totalImages) * 1000) / 1000 ;\r\n        this._data.canvas.element.dispatchEvent( new CustomEvent(eventPrefix + 'loading-progress', {detail: {progress}}) );\r\n        if (e.type === \"error\") {\r\n            this._isLoadedWithErrors = true;\r\n            const path = e.path || (e.composedPath && e.composedPath());\r\n            this._failedImages.push(path[0]);\r\n            this._data.canvas.element.dispatchEvent( new Event(eventPrefix + 'loading-error') );\r\n        }\r\n        if (this._preloadedCount >= this._totalImages) {\r\n            if ( this._isLoadedWithErrors ) this.#clearImagesArray();\r\n            this.#afterPreloadFinishes();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove failed images from array\r\n     */\r\n    #clearImagesArray(){\r\n        if ( this._failedImages.length < 1) return;\r\n        this._tempImagesArray = this._tempImagesArray.filter((el) => {\r\n            return !this._failedImages.includes(el);\r\n        });\r\n    }\r\n\r\n    #afterPreloadFinishes(){ // check what to do next\r\n        if (this._currentMode === \"default\"){\r\n            this._isPreloadFinished = true;\r\n        } else {\r\n            this._isFastPreloadFinished = true;\r\n        }\r\n        this._isAnyPreloadFinished = true; // variable for checks from main plugin\r\n        this._data.loadedImagesArray = [...this._tempImagesArray];\r\n        this._data.totalImages = this._tempImagesArray.length;\r\n        this._updateImagesCount();\r\n\r\n        // we should call deferredAction and callback after \"setFrame\" inside next \"if\", because setFrame will replace\r\n        // these actions, so save current mode before it will be changed inside \"if\", and use for  deferredAction and callback\r\n        const savedMode = this._currentMode;\r\n        const plugin = this._data.pluginApi;\r\n        // code below executes only if fastPreview is set\r\n        if ( this._currentMode === \"fast\" ) { // fast preload has ended\r\n            this._currentMode = \"default\";\r\n            this._tempImagesArray = [];\r\n            this._preloadOffset = this._preloadedCount = 0;\r\n            this._totalImages = this._settings.images.length; // update for default preload mode\r\n            // start preload full list if we have action, that started after fast preload end\r\n            if ( this._data.deferredAction ) this._startLoading();\r\n        } else if ( this._currentMode === \"default\" && this._settings.fastPreview ) { // default preload has ended (only after fast),\r\n            // replace small sequence with full and change frame\r\n            if (this._settings?.fastPreview.fpsAfter) plugin.setOption(\"fps\", this._settings?.fastPreview.fpsAfter)\r\n            const wasAnimating = plugin.isAnimating();\r\n            const framesAreInQueue = typeof this._getFramesLeft() !== 'undefined'; // true if playTo or playFrames is active\r\n            const matchFrame = this._settings?.fastPreview.matchFrame;\r\n            plugin.setFrame( matchFrame ? matchFrame(this._data.currentFrame) : 1 );\r\n            // play() => continue, playTo() or playFrames() => stop, because it is impossible\r\n            // to calculate new target frame from _framesLeftToPlay\r\n            //https://github.com/its2easy/animate-images/issues/7#issuecomment-1210624687\r\n            if ( wasAnimating && !framesAreInQueue ) plugin.play();\r\n        }\r\n\r\n        // actions and callbacks\r\n        if (this._data.deferredAction) {\r\n            this._data.deferredAction();\r\n            // clear to prevent from being called twice when action was queued before the end of fastPreview preload\r\n            this._data.deferredAction = null;\r\n        }\r\n        this._data.canvas.element.dispatchEvent( new Event(this._modes[savedMode].event) );\r\n        this._modes[savedMode].callback(plugin);\r\n\r\n    }\r\n\r\n    // Case when fast preload had ended, but we don't have deferred action, because action started with preview frames,\r\n    // this is possible only with preload=\"all\"; or with any preload after plugin.preloadImages() before any action,\r\n    // and we have to start full preload here.\r\n    // This function is called only after frame change was requested.\r\n    _maybePreloadAll(){\r\n        if (this._settings.fastPreview && !this._isPreloadFinished) this._startLoading();\r\n    }\r\n\r\n}\r\n","export default class Render{\r\n\r\n    constructor( {settings, data} ) {\r\n        this._settings = settings;\r\n        this._data = data;\r\n        /** @type CanvasRenderingContext2D */\r\n        this._context = this._data.canvas.element.getContext(\"2d\");\r\n    }\r\n\r\n    /**\r\n     * @param {HTMLImageElement} imageObject - image object\r\n     */\r\n    _drawFrame(imageObject){\r\n        //this._context.imageSmoothingEnabled = false; // may reduce blurriness, but could make the image worse (resets to true  after resize)\r\n\r\n        let sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight;\r\n        if (this._settings.fillMode === \"cover\") {\r\n            ( {sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight} = this.#getDrawImageCoverProps(imageObject) )\r\n        } else if ( this._settings.fillMode === \"contain\" ) {\r\n            ( {sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight} = this.#getDrawImageContainProps(imageObject) )\r\n        }\r\n\r\n        //console.log(`sx= ${sx}, sy=${sy}, sWidth=${sWidth}, sHeight=${sHeight}, dx=${dx}, dy=${dy}, dWidth=${dWidth}, dHeight=${dHeight}`);\r\n        const canvasEl = this._data.canvas.element;\r\n        this._settings.onBeforeFrame(this._data.pluginApi,\r\n            {context: this._context, width: canvasEl.width, height: canvasEl.height});\r\n\r\n        this._context.drawImage(imageObject, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\r\n\r\n        this._settings.onAfterFrame(this._data.pluginApi,\r\n            {context: this._context, width: canvasEl.width, height: canvasEl.height});\r\n    }\r\n\r\n    _clearCanvas(){\r\n        const canvasEl = this._data.canvas.element;\r\n        this._context.clearRect(0, 0, canvasEl.width, canvasEl.height);\r\n    }\r\n\r\n    #getDrawImageCoverProps(image){\r\n        //https://stackoverflow.com/questions/21961839/simulation-background-size-cover-in-canvas\r\n        let dx = 0,\r\n            dy = 0,\r\n            canvasWidth = this._data.canvas.element.width,\r\n            canvasHeight = this._data.canvas.element.height,\r\n            imageWidth = image.naturalWidth,\r\n            imageHeight = image.naturalHeight,\r\n            offsetX = 0.5,\r\n            offsetY = 0.5,\r\n            minRatio = Math.min(canvasWidth / imageWidth, canvasHeight / imageHeight),\r\n            newWidth = imageWidth * minRatio,   // new prop. width\r\n            newHeight = imageHeight * minRatio,   // new prop. height\r\n            sx, sy, sWidth, sHeight, ar = 1;\r\n\r\n        // decide which gap to fill\r\n        if (newWidth < canvasWidth) ar = canvasWidth / newWidth;\r\n        if (Math.abs(ar - 1) < 1e-14 && newHeight < canvasHeight) ar = canvasHeight / newHeight;  // updated\r\n        newWidth *= ar;\r\n        newHeight *= ar;\r\n\r\n        // calc source rectangle\r\n        sWidth = imageWidth / (newWidth / canvasWidth);\r\n        sHeight = imageHeight / (newHeight / canvasHeight);\r\n\r\n        sx = (imageWidth - sWidth) * offsetX;\r\n        sy = (imageHeight - sHeight) * offsetY;\r\n\r\n        // make sure source rectangle is valid\r\n        if (sx < 0) sx = 0;\r\n        if (sy < 0) sy = 0;\r\n        if (sWidth > imageWidth) sWidth = imageWidth;\r\n        if (sHeight > imageHeight) sHeight = imageHeight;\r\n\r\n        return { sx, sy, sWidth, sHeight, dx, dy, dWidth: canvasWidth, dHeight: canvasHeight };\r\n    }\r\n    #getDrawImageContainProps(image){\r\n        let canvasWidth = this._data.canvas.element.width,\r\n            canvasHeight = this._data.canvas.element.height,\r\n            imageWidth = image.naturalWidth,\r\n            imageHeight = image.naturalHeight,\r\n            sx = 0,\r\n            sy = 0,\r\n            sWidth = imageWidth,\r\n            sHeight = imageHeight,\r\n            dx,\r\n            dy,\r\n            offsetX = 0.5,\r\n            offsetY = 0.5,\r\n            ratioX = canvasWidth / imageWidth,\r\n            ratioY = canvasHeight / imageHeight,\r\n            minRation = Math.min(ratioX, ratioY),\r\n            newWidth = imageWidth * minRation,\r\n            newHeight = imageHeight * minRation;\r\n\r\n        dx = (canvasWidth - newWidth) * offsetX;\r\n        dy = (canvasHeight - newHeight) * offsetY;\r\n\r\n        return { sx, sy, sWidth, sHeight, dx, dy, dWidth: newWidth, dHeight: newHeight};\r\n    }\r\n}\r\n","import { eventPrefix } from \"./settings\";\r\n\r\nexport default class Animation{\r\n    // Public\r\n    _isAnimating;\r\n    _framesLeftToPlay; // frames from playTo() and playFrames()\r\n\r\n    // Internal\r\n    _lastUpdate; // time from RAF\r\n    _duration; // time of the full animation sequence\r\n    _stopRequested;\r\n    _framesQueue; // save decimal part if deltaFrames is not round, to prevent rounding errors\r\n    _progressThreshold; // >35% mea`ns that there was a long task in callstack\r\n\r\n    constructor( {settings, data, changeFrame} ) {\r\n        this._settings = settings;\r\n        this._data = data;\r\n        this._changeFrame = changeFrame;\r\n\r\n        this._stopRequested = false;\r\n        this._isAnimating = false;\r\n        this._framesQueue = 0;\r\n        this._progressThreshold = 0.35;\r\n\r\n        this._updateDuration();\r\n    }\r\n\r\n    _play(){\r\n        this._isAnimating = true;\r\n         this._stopRequested = false; // fix for the case when stopRequested was set inside getNextFrame that was called outside #animate\r\n        if ( !this._data.isAnyFrameChanged ) { // 1st paint, direct call because 1st frame wasn't drawn\r\n            this._changeFrame(1);\r\n            // subtract 1 manually, because changeFrame is calling not from animate(), but directly\r\n            if ( Number.isFinite(this._framesLeftToPlay) ) this._framesLeftToPlay--; // undefined-- = NaN\r\n        }\r\n\r\n         this._lastUpdate = null;// first 'lastUpdate' should be always set in the first raf of the current animation\r\n        requestAnimationFrame(this.#animate.bind(this));\r\n    }\r\n    _stop(){\r\n        const wasAnimating = this._isAnimating;\r\n        this._isAnimating = false;\r\n        this._framesLeftToPlay = undefined;\r\n        if ( wasAnimating ){ // !!! callbacks and events should be called after all the values are reset\r\n            this._data.canvas.element.dispatchEvent( new Event(eventPrefix + 'animation-end') );\r\n            this._settings.onAnimationEnd(this._data.pluginApi);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get next frame number, based on current state and settings\r\n     * @param {Number} deltaFrames -\r\n     * @param {Boolean} reverse\r\n     * @returns {number|*}\r\n     */\r\n    _getNextFrame(deltaFrames, reverse = undefined){\r\n        deltaFrames = Math.floor(deltaFrames); //just to be safe\r\n        // Handle reverse\r\n        if ( reverse === undefined ) reverse = this._settings.reverse;\r\n        let newFrameNumber = reverse ? this._data.currentFrame - deltaFrames : this._data.currentFrame + deltaFrames\r\n\r\n        // Handle loop\r\n        if (this._settings.loop) { // loop and outside of the frames\r\n            if (newFrameNumber <= 0) {\r\n                // for example newFrame = -2, total = 50, newFrame = 50 - abs(-2) = 48\r\n                newFrameNumber = this._data.totalImages - Math.abs(newFrameNumber);\r\n            }\r\n            else if (newFrameNumber > this._data.totalImages) {\r\n                // for example newFrame = 53, total 50, newFrame = newFrame - totalFrames = 53 - 50 = 3\r\n                newFrameNumber = newFrameNumber - this._data.totalImages;\r\n            }\r\n        } else { // no loop and outside of the frames\r\n            if (newFrameNumber <= 0) {\r\n                newFrameNumber = 1;\r\n                this._stopRequested = true;\r\n            }\r\n            else if (newFrameNumber > this._data.totalImages) {\r\n                newFrameNumber = this._data.totalImages;\r\n                 this._stopRequested = true;\r\n            }\r\n        }\r\n        return  newFrameNumber;\r\n    }\r\n\r\n    // RAF callback\r\n    // (chrome) 'timestamp' is timestamp from the moment the RAF callback was queued\r\n    // (firefox) 'timestamp' is timestamp from the moment the RAF callback was called\r\n    // the difference is equal to the time that the main thread was executing after raf callback was queued\r\n    #animate(timestamp){\r\n        if ( !this._isAnimating ) return;\r\n\r\n        // lastUpdate is setting here because the time between play() and #animate() is unpredictable, and\r\n        // lastUpdate = performance.now instead of timestamp because timestamp is unpredictable and depends on the browser.\r\n        // Possible frame change in the first raf will always be skipped, because time <= performance.now\r\n        if ( ! this._lastUpdate)  this._lastUpdate = performance.now();\r\n\r\n        let deltaFrames;\r\n        // Check if there was a long task between this and the last frame, if so move 1 fixed frame and change lastUpdate to now\r\n        // to prevent animation jump. (1,2,3,long task,75,76,77, ... => 1,2,3,long task,4,5,6,...)\r\n        // In this case the duration will be longer\r\n        let isLongTaskBeforeRaf = (Math.abs(timestamp - performance.now()) /  this._duration) >  this._progressThreshold; //chrome check\r\n        let progress = ( timestamp -  this._lastUpdate ) /  this._duration; // e.g. 0.01\r\n        if ( progress >  this._progressThreshold ) isLongTaskBeforeRaf = true; // firefox check\r\n\r\n        if (isLongTaskBeforeRaf) deltaFrames = 1; // raf after long task, just move to the next frame\r\n        else { // normal execution, calculate progress after the last frame change\r\n            if (progress < 0) progress = 0; //it happens sometimes, when raf timestamp is from the past for some reason\r\n            deltaFrames = progress * this._data.totalImages; // Frame change step, e.g. 0.45 or 1.25\r\n            // e.g. progress is 0.8 frames, queue is 0.25 frames, so now deltaFrames is 1.05 frames and we need to update canvas,\r\n            // without this raf intervals will cause cumulative rounding errors, and actual fps will decrease\r\n            deltaFrames = deltaFrames +  this._framesQueue;\r\n        }\r\n\r\n        // calculate next frame only when we want to render\r\n        // if the getNextFrame check was outside, getNextFrame would be called at screen fps rate, not animation fps\r\n        // if screen fps 144 and animation fps 30, getNextFrame is calling now 30/s instead of 144/s.\r\n        // After the last frame, raf is repeating until the next frame calculation,\r\n        // between the last frame drawing and new frame time, reverse or loop could be changed, and animation won't stop\r\n        if ( deltaFrames >= 1) { // Calculate only if we need to update 1 frame or more\r\n            const newLastUpdate = isLongTaskBeforeRaf ? performance.now() : timestamp;\r\n\r\n            this._framesQueue = deltaFrames % 1; // save decimal part for the next RAFs\r\n            deltaFrames = Math.floor(deltaFrames) % this._data.totalImages;\r\n            if ( deltaFrames > this._framesLeftToPlay ) deltaFrames = this._framesLeftToPlay;// case when  animation fps > device fps\r\n            const newFrame = this._getNextFrame( deltaFrames );\r\n            if ( this._stopRequested ) { // animation ended from check in getNextFrame()\r\n                this._data.pluginApi.stop();\r\n                this._stopRequested = false;\r\n                if (this._data.pluginApi.getCurrentFrame() !== newFrame ) this._changeFrame(newFrame); //last frame fix if fps > device fps\r\n            } else { // animation is on\r\n                this._lastUpdate = newLastUpdate;\r\n                this._changeFrame(newFrame);\r\n                if (typeof this._framesLeftToPlay !== 'undefined') {\r\n                    this._framesLeftToPlay = this._framesLeftToPlay - deltaFrames;\r\n                    // if 0 frames left, stop immediately, don't wait for the next frame calculation\r\n                    // because if isAnimating become true, this will be a new animation\r\n                    if ( this._framesLeftToPlay <= 0 ) this._data.pluginApi.stop();\r\n                }\r\n            }\r\n        }\r\n        if ( this._isAnimating ) requestAnimationFrame(this.#animate.bind(this));\r\n    }\r\n\r\n    /**\r\n     * Recalculate animation duration after fps or totalImages change\r\n     */\r\n    _updateDuration(){\r\n         this._duration =  this._data.totalImages / this._settings.fps  * 1000;\r\n    }\r\n}\r\n","import { eventPrefix } from \"./settings\";\r\n\r\nexport default class Poster{\r\n    // Internal\r\n    _imageObject;\r\n    _isPosterLoaded;\r\n\r\n    constructor({settings, data, drawFrame}) {\r\n        this._settings = settings;\r\n        this._data = data;\r\n        this._drawFrame = drawFrame;\r\n\r\n        this._isPosterLoaded = false;\r\n    }\r\n\r\n    /**\r\n     * Start loading poster, then  show if needed\r\n     */\r\n    _loadAndShowPoster(){\r\n        if (this._settings.poster && !this._data.isAnyFrameChanged) {\r\n            this._imageObject = new Image();\r\n            this._imageObject.onload = this._imageObject.onerror = this.#onPosterLoaded.bind(this);\r\n            this._imageObject.src = this._settings.poster;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Redraw poster after canvas change if the poster was loaded\r\n     */\r\n    _redrawPoster(){\r\n        if ( this._data.isAnyFrameChanged || !this._isPosterLoaded ) return;\r\n        this.#drawPoster();\r\n    }\r\n\r\n    #onPosterLoaded(e){\r\n        if (e.type === \"error\") return;\r\n        this._isPosterLoaded = true;\r\n        this._data.canvas.element.dispatchEvent( new Event(eventPrefix + 'poster-loaded') );\r\n        this._settings.onPosterLoaded(this._data.pluginApi);\r\n        // show only if there wasn't any frame change from initial\r\n        // if poster loaded after all the images and any action, it won't be shown\r\n        if ( !this._data.isAnyFrameChanged ) {\r\n            this.#drawPoster();\r\n        }\r\n    }\r\n\r\n    #drawPoster(){\r\n        this._drawFrame(this._imageObject);\r\n    }\r\n}\r\n","import { eventPrefix } from \"./settings\";\r\n\r\nexport default class DragInput{\r\n    // Public\r\n    _isSwiping = false;\r\n\r\n    // Internal\r\n    _curX;\r\n    _curY;\r\n    _prevX;\r\n    _prevY;\r\n    _threshold;\r\n    _pixelsCorrection;\r\n    _lastInteractionTime;\r\n    _prevDirection;\r\n\r\n    constructor({ data, settings, changeFrame, getNextFrame }) {\r\n        this._data = data;\r\n        this._settings = settings;\r\n        this._changeFrame = changeFrame;\r\n        this._getNextFrame = getNextFrame;\r\n\r\n        this._SWIPE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'touchstart', 'touchmove', 'touchend', 'touchcancel'];\r\n        this._isSwiping = false;\r\n        this._boundSwipeHandler = this.#swipeHandler.bind(this);\r\n        this._pixelsCorrection = 0;\r\n\r\n        this._updateThreshold();\r\n    }\r\n\r\n    /**\r\n     * Enable rotating by mouse or touch drag\r\n     */\r\n    _enableDrag(){\r\n        this._SWIPE_EVENTS.forEach( (value) => {\r\n            this._data.canvas.element.addEventListener(value, this._boundSwipeHandler);\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Disable rotating by mouse or touch drag\r\n     */\r\n    _disableDrag(){\r\n        this._SWIPE_EVENTS.forEach( (value) => {\r\n            this._data.canvas.element.removeEventListener(value, this._boundSwipeHandler);\r\n        })\r\n        // if disabling while swipeMove is running\r\n        document.removeEventListener('mouseup', this._boundSwipeHandler);\r\n        document.removeEventListener('mousemove', this._boundSwipeHandler);\r\n        this._data.canvas.element.style.cursor = null;\r\n    }\r\n\r\n    /**\r\n     * Update one frame threshold in pixels\r\n     * @param newValue\r\n     */\r\n    _updateThreshold(newValue = null){\r\n        if (newValue) {\r\n            this._threshold = newValue;\r\n        }\r\n        else {\r\n            this._threshold = this._data.canvas.element.clientWidth / this._data.totalImages;\r\n        }\r\n    }\r\n\r\n\r\n    #swipeHandler(event) {\r\n        // get current click/touch point\r\n        let touches;\r\n        if ( event.touches !== undefined && event.touches.length ) touches = event.touches;\r\n        this._curX = (touches) ? touches[0].pageX : event.clientX;\r\n        this._curY = (touches) ? touches[0].pageY : event.clientY;\r\n\r\n        switch (event.type){\r\n            case 'mousedown': // start\r\n            case 'touchstart':\r\n                if ( event.type === 'touchstart' && event.cancelable ) {\r\n                    //event.preventDefault();\r\n                    this.#maybeDisableScroll(event);\r\n                }\r\n                document.addEventListener('mouseup', this._boundSwipeHandler); // move outside of the canvas\r\n                document.addEventListener('mousemove', this._boundSwipeHandler);\r\n                this.#swipeStart();\r\n                break;\r\n            case 'mousemove':\r\n            case 'touchmove': //move\r\n                // ignore mousemove without move (to prevent fake \"left\" movement)\r\n                const wasMoved = (this._prevX !== this._curX && this._prevY !== this._curX);\r\n                if ( this._isSwiping && wasMoved) {\r\n                    //if ( event.type === 'touchmove' && event.cancelable) event.preventDefault();\r\n                    this.#swipeMove();\r\n                }\r\n                break;\r\n            case 'mouseup':\r\n            case 'touchend':\r\n            case 'touchcancel': // end\r\n                //if ( (event.type === 'touchend' || event.type === 'touchcancel') && event.cancelable) event.preventDefault();\r\n                if ( this._isSwiping ) {\r\n                    document.removeEventListener('mouseup', this._boundSwipeHandler);\r\n                    document.removeEventListener('mousemove', this._boundSwipeHandler);\r\n                    this.#swipeEnd();\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    #swipeStart(){\r\n        const plugin = this._data.pluginApi;\r\n        if ( !(plugin.isFastPreloadFinished() || plugin.isPreloadFinished()) ) return;\r\n        // trigger full load after user interaction after fast preload finished\r\n        if (this._settings.fastPreview && !plugin.isPreloadFinished() && plugin.isFastPreloadFinished()) {\r\n            plugin.preloadImages();\r\n        }\r\n        plugin.stop();\r\n        this._isSwiping = true;\r\n        this._data.canvas.element.style.cursor = 'grabbing';\r\n        this._prevX = this._curX;\r\n        this._prevY = this._curY;\r\n        this._data.canvas.element.dispatchEvent( new CustomEvent(eventPrefix + 'drag-start',\r\n            { detail: {frame: this._data.currentFrame} })\r\n        );\r\n    }\r\n    #swipeMove(){\r\n        const direction = this.#swipeDirection();\r\n        if (this._prevDirection && this._prevDirection !== direction) { // reset after direction change\r\n            this._pixelsCorrection = 0;\r\n        }\r\n        this._prevDirection = direction;\r\n\r\n        const pixelDiffX = Math.abs(this._curX - this._prevX ); // save x diff before update\r\n        const swipeLength = (pixelDiffX + this._pixelsCorrection) * this._settings.dragModifier ;\r\n\r\n        this._prevX = this._curX; // update before any returns\r\n        this._prevY = this._curY; // update Y to prevent wrong angle after many vertical moves\r\n\r\n\r\n        if ( (direction !== 'left' && direction !== 'right') || // Ignore vertical directions\r\n            (swipeLength < this._threshold) ) { // Ignore if less than 1 frame\r\n            this._pixelsCorrection += pixelDiffX; // skip this mousemove, but save horizontal movement\r\n            return;\r\n        }\r\n\r\n\r\n        const progress = swipeLength / this._data.canvas.element.clientWidth; // full width swipe means full length animation\r\n        let deltaFrames = Math.floor(progress * this._data.totalImages);\r\n        deltaFrames = deltaFrames % this._data.totalImages;\r\n        // Add pixels to the next swipeMove if frames equivalent of swipe is not an integer number,\r\n        // e.g one frame is 10px, swipeLength is 13px, we change 1 frame and add 3px to the next swipe,\r\n        // so fullwidth swipe is always rotate sprite for 1 turn (with 'dragModifier' = 1).\r\n        // I divide the whole value by dragModifier because it seems to work as it should\r\n        this._pixelsCorrection = (swipeLength - (this._threshold * deltaFrames)) / this._settings.dragModifier;\r\n        let isReverse = (direction === 'left'); // left means backward (reverse: true)\r\n        if (this._settings.inversion) isReverse = !isReverse;// invert direction\r\n        this._changeFrame(this._getNextFrame( deltaFrames, isReverse )); // left means backward (reverse: true)\r\n        this._data.canvas.element.dispatchEvent( new CustomEvent(eventPrefix + 'drag-change',\r\n            { detail: {\r\n                frame: this._data.currentFrame,\r\n                direction,\r\n            } })\r\n        );\r\n    }\r\n    #swipeEnd(){\r\n        //if ( swipeObject.curX === undefined ) return; // there is no x coord on touch end\r\n        this._curX = this._curY = this._prevX = this._prevY = null;\r\n        this._isSwiping = false;\r\n        this._data.canvas.element.style.cursor = null;\r\n        this._lastInteractionTime = new Date().getTime();\r\n        this._data.canvas.element.dispatchEvent( new CustomEvent(eventPrefix + 'drag-end',\r\n            { detail: {\r\n                frame: this._data.currentFrame,\r\n                direction: this._prevDirection,\r\n            } })\r\n        );\r\n    }\r\n    #swipeDirection(){\r\n        let r, swipeAngle,\r\n            xDist = this._prevX - this._curX,\r\n            yDist = this._prevY - this._curY;\r\n\r\n        // taken from slick.js\r\n        r = Math.atan2(yDist, xDist);\r\n        swipeAngle = Math.round(r * 180 / Math.PI);\r\n        if (swipeAngle < 0) swipeAngle = 360 - Math.abs(swipeAngle);\r\n\r\n        if ( (swipeAngle >= 0 && swipeAngle <= 60) || (swipeAngle <= 360 && swipeAngle >= 300 )) return 'left';\r\n        else if ( swipeAngle >= 120 && swipeAngle <= 240 ) return 'right';\r\n        else if ( swipeAngle >= 241 && swipeAngle <= 299 ) return 'bottom';\r\n        else return 'up';\r\n    }\r\n\r\n    /**\r\n     * Idea from https://github.com/giniedp/spritespin/blob/master/src/plugins/input-drag.ts#L45\r\n     * @param {Event} event\r\n     */\r\n    #maybeDisableScroll(event){\r\n        // always prevent\r\n        if (this._settings.touchScrollMode === \"preventPageScroll\") event.preventDefault();\r\n        // check timer\r\n        if (this._settings.touchScrollMode === \"pageScrollTimer\") {\r\n            const now = new Date().getTime();\r\n            // less time than delay => prevent page scroll\r\n            if (this._lastInteractionTime && (now - this._lastInteractionTime < this._settings.pageScrollTimerDelay) ){\r\n                event.preventDefault();\r\n            } else { // more time than delay or first interaction => clear timer\r\n                this._lastInteractionTime = null;\r\n            }\r\n        }\r\n        // if touchScrollMode=\"allowPageScroll\" => don't prevent scroll\r\n    }\r\n}\r\n","import { normalizeFrameNumber, uppercaseFirstChar } from \"./utils\";\r\nimport { validateInitParameters, defaultSettings } from \"./settings\";\r\nimport ImagePreloader from \"./ImagePreloader\";\r\nimport Render from \"./Render\";\r\nimport Animation from \"./Animation\";\r\nimport Poster from \"./Poster\";\r\nimport DragInput from \"./DragInput\";\r\n\r\n/**\r\n * Animate Images {@link https://github.com/its2easy/animate-images/}\r\n * @example\r\n * let pluginInstance = new AnimateImages(document.querySelector('canvas'), {\r\n *    images: ['img1.jpg', 'img2.jpg', 'img3.jpg'],\r\n *    loop: true,\r\n *    draggable: true,\r\n *    fps: 60,\r\n * });\r\n */\r\nexport default class AnimateImages{\r\n    #settings;\r\n    #data = {\r\n        currentFrame: 1,\r\n        totalImages: null,\r\n        loadedImagesArray: [], // images objects [0 - (images.length-1)]\r\n        deferredAction: null, // call after full preload\r\n        isAnyFrameChanged: false,\r\n        /** @type AnimateImages */\r\n        pluginApi: undefined,\r\n        canvas: {\r\n            element: null,\r\n            ratio: null,\r\n        },\r\n    }\r\n    #boundUpdateCanvasSizes;\r\n    //Classes\r\n    #preloader;\r\n    #render;\r\n    #animation;\r\n    #poster;\r\n    #dragInput;\r\n\r\n    /**\r\n     * Creates plugin instance\r\n     * @param {HTMLCanvasElement} node - canvas element\r\n     * @param {PluginOptions} options\r\n     */\r\n    constructor(node, options){\r\n        validateInitParameters(node, options);\r\n        this.#settings = {...defaultSettings, ...options};\r\n        this.#data.totalImages = this.#settings.images.length;\r\n        this.#data.canvas.element = node;\r\n        this.#data.pluginApi = this;\r\n        this.#boundUpdateCanvasSizes = this.#updateCanvasSizes.bind(this)\r\n        this.#initPlugin();\r\n    }\r\n\r\n    #initPlugin(){\r\n        this.#render = new Render( {settings: this.#settings, data: this.#data} );\r\n        this.#animation = new Animation(\r\n            {settings: this.#settings, data: this.#data, changeFrame:  this.#changeFrame.bind(this)} );\r\n        this.#updateCanvasSizes();\r\n        if ( this.#settings.poster ) this.#setupPoster();\r\n        this.#toggleResizeHandler(true);\r\n        this.#preloader = new ImagePreloader({\r\n            settings: this.#settings,\r\n            data: this.#data,\r\n            updateImagesCount: this.#updateImagesCount.bind(this),\r\n            getFramesLeft: this.#getFramesLeft.bind(this),\r\n        });\r\n        if (this.#settings.preload === 'all' || this.#settings.preload === \"partial\"){\r\n            let preloadNumber = (this.#settings.preload === 'all') ? this.#data.totalImages : this.#settings.preloadNumber;\r\n            if (preloadNumber === 0) preloadNumber = this.#data.totalImages;\r\n            this.#preloader._startLoading(preloadNumber);\r\n        }\r\n        if (this.#settings.autoplay) this.play();\r\n        if ( this.#settings.draggable ) this.#toggleDrag(true);\r\n    }\r\n\r\n    #changeFrame(frameNumber){\r\n        if (frameNumber === this.#data.currentFrame && this.#data.isAnyFrameChanged) return;//skip same frame, except first drawing\r\n        if ( !this.#data.isAnyFrameChanged ) this.#data.isAnyFrameChanged = true;\r\n\r\n        this.#animateCanvas(frameNumber);\r\n        this.#data.currentFrame = frameNumber;\r\n    }\r\n\r\n    #animateCanvas(frameNumber){\r\n        this.#render._clearCanvas();\r\n        this.#render._drawFrame( this.#data.loadedImagesArray[frameNumber - 1] );\r\n    }\r\n\r\n\r\n    #updateCanvasSizes(){\r\n        const canvas = this.#data.canvas;\r\n        /**\r\n         * +++RATIO SECTION+++\r\n         * If no options.ratio, inline canvas width/height will be used (2:1 if not set)\r\n         * Real canvas size is controlled by CSS, inner size will be set based on CSS width and ratio (height should be \"auto\")\r\n         * If height if fixed in CSS, ratio can't be used and inner height will be equal to CSS-defined height\r\n         */\r\n        if ( this.#settings.ratio ) canvas.ratio = this.#settings.ratio;\r\n        // Initial ratio shouldn't be changed. Ratio will only modified after setOption(\"ratio\", newRatio),\r\n        // or after setting css height and plugin.updateCanvas()\r\n        else if ( !canvas.ratio ) {\r\n            canvas.ratio = canvas.element.width / canvas.element.height;\r\n        }\r\n\r\n\r\n        // +++SIZE SECTION+++\r\n        // mainSide is the side from responsiveAspect, it should be controlled by CSS, secondarySide value will be\r\n        // controlled by script\r\n        const dpr = (window.devicePixelRatio).toFixed(2) || 1; // sometimes dpr is like 2.00000000234\r\n        let mainSide = this.#settings.responsiveAspect;// width or height\r\n        let clientMainSide =  \"client\" + uppercaseFirstChar(mainSide); // clientWidth or clientHeight\r\n        let secondarySide = (mainSide === \"width\") ? \"height\" : \"width\";\r\n        let clientSecondarySide = \"client\" + uppercaseFirstChar(secondarySide);// clientWidth or clientHeight\r\n\r\n        // changing width and height won't change real clientWidth and clientHeight if size is fixed by CSS\r\n        const initialClientMainSide = canvas.element[clientMainSide];\r\n        canvas.element[mainSide] = canvas.element[clientMainSide] * dpr;\r\n\r\n        // !!! ONLY if dpr != 1 and canvas css mainSide was not defined => changed width will change clientWidth\r\n        // so we need to recalculate width based on new clientWidth\r\n        if (initialClientMainSide !== canvas.element[clientMainSide]) {\r\n            canvas.element[mainSide] = canvas.element[clientMainSide] * dpr;\r\n        }\r\n\r\n        let rawNewValue = (mainSide === \"width\") ? canvas.element.clientWidth / canvas.ratio : canvas.element.clientHeight * canvas.ratio;\r\n        canvas.element[secondarySide] = Math.round(rawNewValue) * dpr; // \"round\" for partial fix to rounding pixels error\r\n\r\n\r\n        // +++CORRECTION SECTION+++\r\n        const secondaryValueDifference = Math.abs(canvas.element[secondarySide] - canvas.element[clientSecondarySide] * dpr);// diff in pixels\r\n        // previously I compared with 1px to check subpixel errors, but error is somehow related to dpr, so we compare with \"1px * dpr\" or just \"dpr\"\r\n        if ( secondaryValueDifference > dpr) { // if secondarySide is locked by CSS\r\n            let newRatio = canvas.element.clientWidth / canvas.element.clientHeight; // ratio from \"real\" canvas element\r\n            // <1% change => calculation error; >1% change => secondarySide size is locked with css\r\n            if ( Math.abs(canvas.ratio - newRatio) / canvas.ratio > 0.01 ) {\r\n                canvas.element[secondarySide] = canvas.element[clientSecondarySide] * dpr;\r\n                canvas.ratio = newRatio;\r\n            } else { // small diff between inner and real values, adjust to prevent errors accumulation\r\n                canvas.element[secondarySide] = (mainSide === \"width\") ? canvas.element.width / canvas.ratio : canvas.element.height * canvas.ratio;\r\n            }\r\n        } else if (secondaryValueDifference > 0 && secondaryValueDifference <= dpr ) { // rare case, pixels are fractional\r\n            // so just update inner canvas size baser on main side and ratio\r\n            canvas.element[secondarySide] = (mainSide === \"width\") ? canvas.element.width / canvas.ratio : canvas.element.height * canvas.ratio;\r\n        }\r\n\r\n        if ( this.#dragInput ) this.#dragInput._updateThreshold()\r\n        this.#maybeRedrawFrame(); // canvas is clear after resize\r\n    }\r\n\r\n    #updateImagesCount(){\r\n        if ( this.#dragInput ) this.#dragInput._updateThreshold();\r\n        this.#animation._updateDuration();\r\n    }\r\n    #maybeRedrawFrame(){\r\n        if ( this.#data.isAnyFrameChanged ) { // frames were drawn\r\n            this.#animateCanvas(this.#data.currentFrame);\r\n        } else if ( this.#poster ) { // poster exists\r\n            this.#poster._redrawPoster();\r\n        }\r\n        // don't redraw in initial state, or if poster onLoad is not finished yet\r\n    }\r\n\r\n    #toggleDrag(enable){\r\n        if (enable) {\r\n            if ( !this.#dragInput ) this.#dragInput = new DragInput({\r\n                data: this.#data,\r\n                settings: this.#settings,\r\n                changeFrame: this.#changeFrame.bind(this),\r\n                getNextFrame: this.#animation._getNextFrame.bind(this.#animation)\r\n            });\r\n            this.#dragInput._enableDrag();\r\n        } else {\r\n            if (this.#dragInput) this.#dragInput._disableDrag();\r\n        }\r\n    }\r\n\r\n    #setupPoster(){\r\n        if (!this.#poster) this.#poster = new Poster(\r\n            {\r\n                settings: this.#settings,\r\n                data: this.#data,\r\n                drawFrame: this.#render._drawFrame.bind(this.#render)\r\n            });\r\n        this.#poster._loadAndShowPoster();\r\n    }\r\n\r\n    #toggleResizeHandler(add = true) {\r\n        if ( add ) window.addEventListener(\"resize\", this.#boundUpdateCanvasSizes);\r\n        else window.removeEventListener(\"resize\", this.#boundUpdateCanvasSizes);\r\n    }\r\n\r\n    #getFramesLeft(){\r\n        return this.#animation._framesLeftToPlay;\r\n    }\r\n\r\n    // Pubic API\r\n\r\n    /**\r\n     * Start animation\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    play(){\r\n        if ( this.#animation._isAnimating ) return this;\r\n        if ( this.#preloader._isAnyPreloadFinished ) {\r\n            this.#animation._play();\r\n            this.#preloader._maybePreloadAll();\r\n        } else {\r\n            this.#data.deferredAction = this.play.bind(this);\r\n            this.#preloader._startLoading();\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Stop animation\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    stop(){\r\n        this.#animation._stop();\r\n        return this;\r\n    }\r\n    /**\r\n     * Toggle between start and stop\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    toggle(){\r\n        if ( !this.#animation._isAnimating ) this.play();\r\n        else this.stop();\r\n        return this;\r\n    }\r\n    /**\r\n     * Show next frame\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    next(){\r\n        if ( this.#preloader._isAnyPreloadFinished ) {\r\n            this.stop();\r\n            this.#changeFrame( this.#animation._getNextFrame(1) );\r\n            this.#preloader._maybePreloadAll();\r\n        } else {\r\n            this.#data.deferredAction = this.next.bind(this);\r\n            this.#preloader._startLoading();\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Show previous frame\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    prev(){\r\n        if ( this.#preloader._isAnyPreloadFinished ) {\r\n            this.stop();\r\n            this.#changeFrame( this.#animation._getNextFrame(1, !this.#settings.reverse) );\r\n            this.#preloader._maybePreloadAll();\r\n        } else {\r\n            this.#data.deferredAction = this.prev.bind(this);\r\n            this.#preloader._startLoading();\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Show a frame with a specified number (without animation)\r\n     * @param {number} frameNumber - Number of the frame to show\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    setFrame(frameNumber){\r\n        if ( this.#preloader._isAnyPreloadFinished ) {\r\n            this.stop();\r\n            this.#changeFrame(normalizeFrameNumber(frameNumber, this.#data.totalImages));\r\n            this.#preloader._maybePreloadAll();\r\n        } else {\r\n            this.#data.deferredAction = this.setFrame.bind(this, frameNumber);\r\n            this.#preloader._startLoading();\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Start animation, that plays until the specified frame number\r\n     * @param {number} frameNumber - Target frame number\r\n     * @param {Object} [options] - Options\r\n     * @param {boolean} [options.shortestPath=false] - If set to true and loop enabled, will use the shortest path\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    playTo(frameNumber, options){\r\n        frameNumber = normalizeFrameNumber(frameNumber, this.#data.totalImages);\r\n\r\n        const innerPathDistance = Math.abs(frameNumber - this.#data.currentFrame), // not crossing edge frames\r\n            outerPathDistance = this.#data.totalImages - innerPathDistance, // crossing edges frames\r\n            shouldUseOuterPath = this.#settings.loop && options?.shortestPath && (outerPathDistance < innerPathDistance);\r\n\r\n        if ( !shouldUseOuterPath ) { // Inner path (default)\r\n            // long conditions to make them more readable\r\n            if (frameNumber > this.#data.currentFrame) this.setReverse(false); // move forward\r\n            else this.setReverse(true); // move backward\r\n        } else { // Outer path\r\n            if (frameNumber < this.#data.currentFrame) this.setReverse(false); // move forward\r\n            else this.setReverse(true); // move backward\r\n        }\r\n\r\n        return this.playFrames( (shouldUseOuterPath) ? outerPathDistance : innerPathDistance );\r\n    }\r\n    /**\r\n     * Start animation in the current direction with the specified number of frames in the queue\r\n     * @param {number} [numberOfFrames=0] - Number of frames to play\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    playFrames(numberOfFrames = 0){\r\n        if ( this.#preloader._isAnyPreloadFinished ) {\r\n            numberOfFrames = Math.floor(numberOfFrames);\r\n            if (numberOfFrames < 0) { // first frame should be rendered to replace poster or transparent bg, so allow 0 for the first time\r\n                return this.stop(); //empty animation, stop() to trigger events and callbacks\r\n            }\r\n\r\n            // if this is the 1st animation, we should add 1 frame to the queue to draw the 1st initial frame\r\n            // because 1st frame is not drawn by default (1 frame will replace poster or transparent bg)\r\n            if (!this.#data.isAnyFrameChanged) numberOfFrames += 1;\r\n            if (numberOfFrames <= 0) { // with playFrames(0) before any actions numberOfFrames=1, after any frame change numberOfFrames=0\r\n                return this.stop(); //empty animation\r\n            }\r\n\r\n            this.#animation._framesLeftToPlay = numberOfFrames;\r\n            this.play();\r\n            this.#preloader._maybePreloadAll();\r\n        } else {\r\n            this.#data.deferredAction = this.playFrames.bind(this, numberOfFrames);\r\n            this.#preloader._startLoading();\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Change the direction of the animation. Alias to <b>setOption('reverse', true)</b>\r\n     * @param {boolean} [reverse=true] - true for backward animation, false for forward, default \"true\"\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    setReverse(reverse = true){\r\n        this.#settings.reverse = !!reverse;\r\n        return this;\r\n    }\r\n    /**\r\n     * Get current reverse option. Alias to <b>getOption('reverse')</b>\r\n     * @returns {boolean} - reverse or not\r\n     */\r\n    getReverse() { return this.#settings.reverse; }\r\n    /**\r\n     * Change the direction of the animation. It does the opposite effect of <b>setReverse()</b>\r\n     * @param {boolean} [forward=true] - true for forward animation, false for backward, default \"true\"\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    setForward(forward = true){\r\n        this.#settings.reverse = !forward;\r\n        return this;\r\n    }\r\n    /**\r\n     * Start preload specified number of images, can be called multiple times.\r\n     * If all the images are already loaded, then nothing will happen\r\n     * @param {number} number - Number of images to load. If not specified, all remaining images will be loaded.\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    preloadImages(number= undefined){\r\n        number = number ?? this.#settings.images.length;\r\n        this.#preloader._startLoading(number);\r\n        return this;\r\n    }\r\n    /**\r\n     * Calculate new canvas dimensions. Should be called after the canvas size was changed manually\r\n     * Called automatically after page resize\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    updateCanvas(){\r\n        this.#updateCanvasSizes();\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns option value\r\n     * @param {string} option - Option name. All options are allowed\r\n     * @returns {*} - Current option value\r\n     */\r\n    getOption(option){\r\n        if ( option in this.#settings ) {\r\n            return this.#settings[option];\r\n        } else {\r\n            console.warn(`${option} is not a valid option`);\r\n        }\r\n    }\r\n    /**\r\n     * Set new option value\r\n     * @param {string} option - Option name. Allowed options: fps, loop, reverse, inversion, ratio, fillMode, draggable, dragModifier,\r\n     * touchScrollMode, pageScrollTimerDelay, onPreloadFinished, onPosterLoaded, onAnimationEnd, onBeforeFrame, onAfterFrame\r\n     * @param {*} value - New value\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    setOption(option, value) {\r\n        const allowedOptions = ['fps', 'loop', 'reverse', 'inversion', 'ratio', 'fillMode', 'draggable', 'dragModifier', 'touchScrollMode',\r\n            'pageScrollTimerDelay', 'onPreloadFinished', 'onFastPreloadFinished', 'onPosterLoaded', 'onAnimationEnd', 'onBeforeFrame', 'onAfterFrame'];\r\n        if (allowedOptions.includes(option)) {\r\n           this.#settings[option] = value;\r\n           if (option === 'fps') this.#animation._updateDuration();\r\n           if (option === 'ratio') this.#updateCanvasSizes();\r\n           if (option === 'fillMode') this.#updateCanvasSizes();\r\n           if (option === 'draggable') this.#toggleDrag(value);\r\n           if (option === 'dragModifier') this.#settings.dragModifier = Math.abs(+value);\r\n        } else {\r\n            console.warn(`${option} is not allowed in setOption`);\r\n        }\r\n        return this;\r\n    }\r\n    /** @returns {number} - current frame number */\r\n    getCurrentFrame() { return this.#data.currentFrame }\r\n    /** @returns {number} - total frames (considering loading errors) */\r\n    getTotalImages() { return this.#data.totalImages }\r\n    /** @returns {number} - current canvas ratio */\r\n    getRatio() { return this.#data.canvas.ratio }\r\n    /** @returns {boolean} - animating or not */\r\n    isAnimating() { return this.#animation._isAnimating }\r\n    /** @returns {boolean} - returns true if a drag action is in progress */\r\n    isDragging() {\r\n        if ( this.#dragInput ) return this.#dragInput._isSwiping;\r\n        return false\r\n    }\r\n    /** @returns {boolean} - is preload finished */\r\n    isPreloadFinished() { return this.#preloader._isPreloadFinished }\r\n    /** @returns {boolean} - is fast preview mode preload finished */\r\n    isFastPreloadFinished() { return this.#preloader._isFastPreloadFinished }\r\n    /** @returns {boolean} - is loaded with errors */\r\n    isLoadedWithErrors() { return this.#preloader._isLoadedWithErrors }\r\n\r\n    /**\r\n     * Stop the animation and return to the first frame\r\n     * @returns {AnimateImages} - plugin instance\r\n     */\r\n    reset(){\r\n        if ( this.#preloader._isAnyPreloadFinished ) {\r\n            this.stop();\r\n            this.#changeFrame(normalizeFrameNumber(1, this.#data.totalImages));\r\n            this.#preloader._maybePreloadAll();\r\n        } else {\r\n            this.#data.deferredAction = this.reset.bind(this);\r\n            this.#preloader._startLoading();\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Stop animation, remove event listeners and clear the canvas. Method doesn't remove canvas element from the DOM\r\n     */\r\n    destroy(){\r\n        this.stop();\r\n        this.#render._clearCanvas();\r\n        this.#toggleDrag(false);\r\n        this.#toggleResizeHandler(false);\r\n    }\r\n}\r\n/**\r\n * NOTE\r\n * All internal classes have public methods and properties start with _, that's for terser plugin that can mangle internal names\r\n * by regexp. It's reducing size by about 20%. Private (#) properties are not used in internal classes because babel use wrapper\r\n * functions for these properties, which increases the size even though private names are minified\r\n */\r\n\r\n/**\r\n * @typedef {Object} PluginOptions\r\n * @property {Array<string>} images - Array with images URLs (required)\r\n * @property {'all'|'partial'|'none'} [preload=\"all\"] - Preload mode (\"all\", \"none\", \"partial\")\r\n * @property {number} [preloadNumber=0] - Number of preloaded images when <b>preload: \"partial\"</b>, 0 for all\r\n * @property {string} [poster] - Url of a poster image, to show before load\r\n * @property {number} [fps=30] - FPS when playing. Determines the duration of the animation (for example 90 images and 60\r\n * fps = 1.5s, 90 images and 30fps = 3s)\r\n * @property {boolean} [loop=false] - Loop the animation\r\n * @property {boolean} [autoplay=false] - Autoplay\r\n * @property {boolean} [reverse=false] - Reverse direction\r\n * reverse means forward or backward, and inversion determines which direction is forward. Affects animation and drag\r\n * @property {number} [ratio] - Canvas width/height ratio, it has higher priority than inline canvas width and height\r\n * @property {'cover'|'contain'} [fillMode=\"cover\"] - Fill mode to use if canvas and image aspect ratios are different\r\n * (\"cover\" or \"contain\")\r\n * @property {boolean} [draggable=false] - Draggable by mouse or touch\r\n * @property {boolean} [inversion=false] - Inversion changes drag direction\r\n * @property {number} [dragModifier=1] - Sensitivity factor for user interaction. Only positive numbers are allowed\r\n * @property {'pageScrollTimer' | 'preventPageScroll' | 'allowPageScroll'} [touchScrollMode = \"pageScrollTimer\"] - Page\r\n * scroll behavior with touch events (preventPageScroll,allowPageScroll, pageScrollTimer)\r\n * @property {number} [pageScrollTimerDelay=1500] - Time in ms when touch scroll will be disabled during interaction\r\n * if <b>touchScrollMode: \"pageScrollTimer\"<b>\r\n * @property {'width'|'height'} [responsiveAspect=\"width\"] - Which side will be responsive (controlled by css)\r\n * @property {Object|false} [fastPreview=false] - Special mode for interactivity after loading only a part of the pictures\r\n * @property {Array<string>} [fastPreview.images] - images urls for fastPreview mode (<b>Required</b> if fastPreview is enabled)\r\n * @property {number} [fastPreview.fpsAfter] - fps value that will be applied after the full list of images is loaded\r\n * @property {function(number):number} [fastPreview.matchFrame] - A function that takes the frame number of the short set\r\n * and returns the frame number of the full set, to prevent jump after full load.\r\n * @property {function(AnimateImages):void} [onPreloadFinished] - Occurs when all image files have been loaded\r\n * @property {function(AnimateImages):void} [onFastPreloadFinished] - Occurs when all fastPreview mode images have been loaded\r\n * @property {function(AnimateImages):void} [onPosterLoaded] - Occurs when poster image is fully loaded\r\n * @property {function(AnimateImages):void} [onAnimationEnd] - Occurs when animation has ended\r\n * @property {function(AnimateImages, FrameInfo):void} [onBeforeFrame] - Occurs before new frame\r\n * @property {function(AnimateImages, FrameInfo):void} [onAfterFrame] - Occurs after the frame was drawn\r\n */\r\n\r\n/**\r\n * @typedef {Object} FrameInfo\r\n * @property {CanvasRenderingContext2D} context - canvas context\r\n * @property {number} width - internal canvas width\r\n * @property {number} height - internal canvas height\r\n * */\r\n"],"names":["normalizeFrameNumber","frameNumber","totalImages","Math","floor","uppercaseFirstChar","word","charAt","toUpperCase","slice","defaultSettings","preload","preloadNumber","poster","fps","loop","autoplay","reverse","ratio","undefined","fillMode","draggable","inversion","dragModifier","touchScrollMode","pageScrollTimerDelay","responsiveAspect","fastPreview","onFastPreloadFinished","noOp","onPreloadFinished","onPosterLoaded","onAnimationEnd","onBeforeFrame","onAfterFrame","eventPrefix","ImagePreloader","constructor","_ref","_this$_settings","settings","data","updateImagesCount","getFramesLeft","_classPrivateMethodInitSpec","this","_afterPreloadFinishes","_clearImagesArray","_onImageLoad","_settings","_data","_updateImagesCount","_getFramesLeft","_isPreloadFinished","_isFastPreloadFinished","_isAnyPreloadFinished","_isLoadedWithErrors","_preloadOffset","_preloadedCount","_tempImagesArray","_failedImages","_currentMode","_modes","default","images","event","callback","fast","TypeError","length","_totalImages","_startLoading","round","unloadedCount","i","img","Image","onload","onerror","_classPrivateMethodGet","bind","src","_maybePreloadAll","e","progress","canvas","element","dispatchEvent","CustomEvent","detail","type","path","composedPath","push","Event","_clearImagesArray2","call","_afterPreloadFinishes2","filter","el","includes","loadedImagesArray","savedMode","plugin","pluginApi","deferredAction","_this$_settings2","_this$_settings3","_this$_settings4","fpsAfter","setOption","wasAnimating","isAnimating","framesAreInQueue","matchFrame","setFrame","currentFrame","play","Render","_getDrawImageContainProps","_getDrawImageCoverProps","_context","getContext","_drawFrame","imageObject","sx","sy","sWidth","sHeight","dx","dy","dWidth","dHeight","_getDrawImageCoverProps2","_getDrawImageContainProps2","canvasEl","context","width","height","drawImage","_clearCanvas","clearRect","image","canvasWidth","canvasHeight","imageWidth","naturalWidth","imageHeight","naturalHeight","minRatio","min","newWidth","newHeight","ar","abs","ratioX","ratioY","minRation","Animation","changeFrame","_animate","_defineProperty","_changeFrame","_stopRequested","_isAnimating","_framesQueue","_progressThreshold","_updateDuration","_play","isAnyFrameChanged","Number","isFinite","_framesLeftToPlay","_lastUpdate","requestAnimationFrame","_animate2","_stop","_getNextFrame","deltaFrames","newFrameNumber","_duration","timestamp","performance","now","isLongTaskBeforeRaf","newLastUpdate","newFrame","stop","getCurrentFrame","Poster","drawFrame","_drawPoster","_onPosterLoaded","_isPosterLoaded","_loadAndShowPoster","_imageObject","_onPosterLoaded2","_redrawPoster","_drawPoster2","DragInput","getNextFrame","_maybeDisableScroll","_swipeDirection","_swipeEnd","_swipeMove","_swipeStart","_swipeHandler","_SWIPE_EVENTS","_isSwiping","_boundSwipeHandler","_swipeHandler2","_pixelsCorrection","_updateThreshold","_enableDrag","forEach","value","addEventListener","_disableDrag","removeEventListener","document","style","cursor","newValue","_threshold","clientWidth","touches","_curX","pageX","clientX","_curY","pageY","clientY","cancelable","_maybeDisableScroll2","_swipeStart2","wasMoved","_prevX","_prevY","_swipeMove2","_swipeEnd2","isFastPreloadFinished","isPreloadFinished","preloadImages","frame","direction","_swipeDirection2","_prevDirection","pixelDiffX","swipeLength","isReverse","_lastInteractionTime","Date","getTime","r","swipeAngle","xDist","yDist","atan2","PI","preventDefault","AnimateImages","node","options","_toggleResizeHandler","_setupPoster","_toggleDrag","_maybeRedrawFrame","_updateCanvasSizes","_animateCanvas","_initPlugin","_classPrivateFieldInitSpec","writable","_boundUpdateCanvasSizes","_preloader","_render","_animation","_poster","_dragInput","HTMLCanvasElement","Array","isArray","parseInt","validateInitParameters","_classPrivateFieldSet","_classPrivateFieldGet","_initPlugin2","toggle","next","_changeFrame2","prev","playTo","innerPathDistance","outerPathDistance","shouldUseOuterPath","shortestPath","setReverse","playFrames","numberOfFrames","getReverse","setForward","forward","number","updateCanvas","_updateCanvasSizes2","getOption","option","console","warn","getTotalImages","getRatio","isDragging","isLoadedWithErrors","reset","destroy","_toggleDrag2","_toggleResizeHandler2","_setupPoster2","_updateImagesCount2","_animateCanvas2","dpr","window","devicePixelRatio","toFixed","mainSide","clientMainSide","secondarySide","clientSecondarySide","initialClientMainSide","rawNewValue","clientHeight","secondaryValueDifference","newRatio","_maybeRedrawFrame2","enable","add","_getFramesLeft2"],"mappings":"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"}